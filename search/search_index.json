{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Artigraph","text":"<p>Artigraph is a library for creating and working with interrelated graphs of data artifacts. It's best used in conjunction with data pipeline tools like Prefect or Dask. Under the hood, Artigraph uses SQLAlchemy and is compatible with most major relational databases including PostgreSQL, MySQL, and SQLite. It also supports popular tools like Pydantic, Numpy, and Pandas.</p>"},{"location":"#at-a-glance","title":"At a Glance","text":"<p>The script below creates a graph of data artifacts and displays it using NetworkX and Plotly.</p> <p>Note</p> <p>Running this script will require you to <code>pip install \"artigraph[networkx,plotly]\" aiosqlite</code></p> <pre><code>import artigraph as ag\nfrom artigraph.extras.networkx import create_graph\nfrom artigraph.extras.plotly import figure_from_networkx\n# configure what engine artigraph will use\nag.set_engine(\"sqlite+aiosqlite:///example.db\", create_tables=True)\n# define a model of your data\n@ag.dataclass\nclass MyModel(ag.GraphModel, version=1):\nsome_value: int\nanother_value: dict[str, str]\n# create a node, a model, and a link between them\nnode = ag.Node()\nmodel = MyModel(some_value=42, another_value={\"foo\": \"bar\"})\nlink = ag.Link(source_id=node.graph_id, target_id=model.graph_id, label=\"my_model\")\n# write them to the database\nag.write_many([node, model, link])\n# create and display the resulting graph\ngraph = create_graph(node)\nfig = figure_from_networkx(graph)\nfig.show()\n</code></pre>"},{"location":"api/","title":"Reference","text":"<p>S3 storage backend for Artigraph.</p>"},{"location":"api/#artigraph.datetime_serializer","title":"datetime_serializer  <code>module-attribute</code>","text":"<pre><code>datetime_serializer = DatetimeSerializer().register()\n</code></pre> <p>An iso8601 serializer for datetime objects.</p>"},{"location":"api/#artigraph.json_serializer","title":"json_serializer  <code>module-attribute</code>","text":"<pre><code>json_serializer = JsonSerializer().register()\n</code></pre> <p>A serializer for JSON.</p>"},{"location":"api/#artigraph.json_sorted_serializer","title":"json_sorted_serializer  <code>module-attribute</code>","text":"<pre><code>json_sorted_serializer = JsonSerializer(\nsort_keys=True\n).register()\n</code></pre> <p>A serializer for JSON with sorted keys</p>"},{"location":"api/#artigraph.temp_file_storage","title":"temp_file_storage  <code>module-attribute</code>","text":"<pre><code>temp_file_storage = FileSystemStorage(\ntemp_dir.name\n).register()\n</code></pre> <p>A temporary file storage backend (best for testing).</p>"},{"location":"api/#artigraph.Artifact","title":"Artifact","text":"<p>             Bases: <code>Node[OrmArtifact]</code>, <code>Generic[T]</code></p> <p>A wrapper around an ORM artifact record.</p> Source code in <code>src/artigraph/core/api/artifact.py</code> <pre><code>class Artifact(Node[OrmArtifact], Generic[T]):\n\"\"\"A wrapper around an ORM artifact record.\"\"\"\ngraph_orm_type: ClassVar[type[OrmArtifact]] = OrmArtifact\nvalue: T\nserializer: Serializer | None = None\nstorage: Storage | None = None\nasync def graph_dump_self(self) -&gt; OrmArtifact:\nif self.serializer is not None:\nserializer_name = self.serializer.name\nif self.value is None:\ndata = None\nelse:\ndata = self.serializer.serialize(self.value)\nelif isinstance(self.value, bytes):\nserializer_name = None\ndata = self.value\nelse:\nserializer = get_serializer_by_type(type(self.value))[0]\ndata = serializer.serialize(self.value)\nserializer_name = serializer.name\nif data is not None and self.storage is not None:\nlocation = await self.storage.create(data)\nartifact = OrmRemoteArtifact(\nid=self.graph_id,\nartifact_serializer=serializer_name,\nremote_artifact_storage=self.storage.name,\nremote_artifact_location=location,\n)\nelse:\nartifact = OrmDatabaseArtifact(\nid=self.graph_id,\nartifact_serializer=serializer_name,\ndatabase_artifact_data=data,\n)\nreturn artifact\n@classmethod\nasync def _graph_load_extra_kwargs(cls, self_record: OrmArtifact) -&gt; dict[str, Any]:\nreturn {\n**await super()._graph_load_extra_kwargs(self_record),\n\"value\": await load_deserialized_artifact_value(self_record),\n\"serializer\": (\nget_serializer_by_name(self_record.artifact_serializer)\nif self_record.artifact_serializer\nelse None\n),\n\"storage\": (\nget_storage_by_name(self_record.remote_artifact_storage)\nif isinstance(self_record, OrmRemoteArtifact)\nelse None\n),\n}\n</code></pre>"},{"location":"api/#artigraph.ArtifactFilter","title":"ArtifactFilter","text":"<p>             Bases: <code>NodeFilter[A]</code></p> <p>Filter artifacts that meet the given conditions.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>class ArtifactFilter(NodeFilter[A]):\n\"\"\"Filter artifacts that meet the given conditions.\"\"\"\nnode_type: NodeTypeFilter[A] = field(\n# delay this in case tables are defined late\ndefault_factory=lambda: NodeTypeFilter(type=[OrmArtifact])  # type: ignore\n)\n\"\"\"Artifacts must be one of these types.\"\"\"\n</code></pre>"},{"location":"api/#artigraph.ArtifactFilter.node_type","title":"node_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>node_type: NodeTypeFilter[A] = field(\ndefault_factory=lambda: NodeTypeFilter(\ntype=[OrmArtifact]\n)\n)\n</code></pre> <p>Artifacts must be one of these types.</p>"},{"location":"api/#artigraph.DatetimeSerializer","title":"DatetimeSerializer","text":"<p>             Bases: <code>Serializer</code></p> <p>Serializer for datetime.datetime.</p> Source code in <code>src/artigraph/core/serializer/datetime.py</code> <pre><code>class DatetimeSerializer(Serializer):\n\"\"\"Serializer for datetime.datetime.\"\"\"\nname = \"artigraph-datetime\"\ntypes = (datetime,)\ndef serialize(self, value: datetime) -&gt; bytes:\n\"\"\"Serialize a datetime.datetime to an ISO 8601 string.\"\"\"\nreturn value.isoformat().encode()\ndef deserialize(self, value: bytes) -&gt; datetime:\n\"\"\"Deserialize an ISO 8601 string to a datetime.datetime.\"\"\"\nreturn datetime.fromisoformat(value.decode())\n</code></pre>"},{"location":"api/#artigraph.DatetimeSerializer.deserialize","title":"deserialize","text":"<pre><code>deserialize(value: bytes) -&gt; datetime\n</code></pre> <p>Deserialize an ISO 8601 string to a datetime.datetime.</p> Source code in <code>src/artigraph/core/serializer/datetime.py</code> <pre><code>def deserialize(self, value: bytes) -&gt; datetime:\n\"\"\"Deserialize an ISO 8601 string to a datetime.datetime.\"\"\"\nreturn datetime.fromisoformat(value.decode())\n</code></pre>"},{"location":"api/#artigraph.DatetimeSerializer.serialize","title":"serialize","text":"<pre><code>serialize(value: datetime) -&gt; bytes\n</code></pre> <p>Serialize a datetime.datetime to an ISO 8601 string.</p> Source code in <code>src/artigraph/core/serializer/datetime.py</code> <pre><code>def serialize(self, value: datetime) -&gt; bytes:\n\"\"\"Serialize a datetime.datetime to an ISO 8601 string.\"\"\"\nreturn value.isoformat().encode()\n</code></pre>"},{"location":"api/#artigraph.FileSystemStorage","title":"FileSystemStorage","text":"<p>             Bases: <code>Storage</code></p> <p>A storage backend that saves artifacts to the filesystem.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>str | Path</code> <p>The directory to save artifacts to.</p> required <code>name</code> <code>str</code> <p>The name of the storage backend.</p> <code>''</code> Source code in <code>src/artigraph/core/storage/file.py</code> <pre><code>class FileSystemStorage(Storage):\n\"\"\"A storage backend that saves artifacts to the filesystem.\n    Parameters:\n        directory: The directory to save artifacts to.\n        name: The name of the storage backend.\n    \"\"\"\ndef __init__(self, directory: str | Path, name: str = \"\") -&gt; None:\nself.dir = Path(directory)\nself.name = slugify(f\"artigraph-file-system-{name or self.dir}\")\nasync def create(self, data: bytes) -&gt; str:\n\"\"\"Create an artifact in the filesystem and return its location\"\"\"\nkey = uuid4().hex\npath = self.dir / key\npath.write_bytes(data)\nreturn key\nasync def read(self, key: str) -&gt; bytes:\n\"\"\"Read an artifact from the filesystem.\"\"\"\npath = self.dir / key\nreturn path.read_bytes()\nasync def update(self, key: str, data: bytes) -&gt; None:\n\"\"\"Update an artifact in the filesystem.\"\"\"\npath = self.dir / key\npath.write_bytes(data)\nasync def delete(self, key: str) -&gt; None:\n\"\"\"Delete an artifact from the filesystem.\"\"\"\npath = self.dir / key\npath.unlink()\nasync def exists(self, key: str) -&gt; bool:\n\"\"\"Check if an artifact exists in the filesystem.\"\"\"\npath = self.dir / key\nreturn path.exists()\n</code></pre>"},{"location":"api/#artigraph.FileSystemStorage.create","title":"create  <code>async</code>","text":"<pre><code>create(data: bytes) -&gt; str\n</code></pre> <p>Create an artifact in the filesystem and return its location</p> Source code in <code>src/artigraph/core/storage/file.py</code> <pre><code>async def create(self, data: bytes) -&gt; str:\n\"\"\"Create an artifact in the filesystem and return its location\"\"\"\nkey = uuid4().hex\npath = self.dir / key\npath.write_bytes(data)\nreturn key\n</code></pre>"},{"location":"api/#artigraph.FileSystemStorage.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Delete an artifact from the filesystem.</p> Source code in <code>src/artigraph/core/storage/file.py</code> <pre><code>async def delete(self, key: str) -&gt; None:\n\"\"\"Delete an artifact from the filesystem.\"\"\"\npath = self.dir / key\npath.unlink()\n</code></pre>"},{"location":"api/#artigraph.FileSystemStorage.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if an artifact exists in the filesystem.</p> Source code in <code>src/artigraph/core/storage/file.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n\"\"\"Check if an artifact exists in the filesystem.\"\"\"\npath = self.dir / key\nreturn path.exists()\n</code></pre>"},{"location":"api/#artigraph.FileSystemStorage.read","title":"read  <code>async</code>","text":"<pre><code>read(key: str) -&gt; bytes\n</code></pre> <p>Read an artifact from the filesystem.</p> Source code in <code>src/artigraph/core/storage/file.py</code> <pre><code>async def read(self, key: str) -&gt; bytes:\n\"\"\"Read an artifact from the filesystem.\"\"\"\npath = self.dir / key\nreturn path.read_bytes()\n</code></pre>"},{"location":"api/#artigraph.FileSystemStorage.update","title":"update  <code>async</code>","text":"<pre><code>update(key: str, data: bytes) -&gt; None\n</code></pre> <p>Update an artifact in the filesystem.</p> Source code in <code>src/artigraph/core/storage/file.py</code> <pre><code>async def update(self, key: str, data: bytes) -&gt; None:\n\"\"\"Update an artifact in the filesystem.\"\"\"\npath = self.dir / key\npath.write_bytes(data)\n</code></pre>"},{"location":"api/#artigraph.Filter","title":"Filter","text":"<p>             Bases: <code>FrozenDataclass</code></p> <p>Base class for where clauses.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>class Filter(FrozenDataclass):\n\"\"\"Base class for where clauses.\"\"\"\ndef create(self) -&gt; Expression:\n\"\"\"Return the condition represented by this filter.\"\"\"\nreturn self.compose(_NO_OP)\ndef compose(self, expr: Expression, /) -&gt; Expression:\n\"\"\"Apply the where clause to the given query.\"\"\"\nraise NotImplementedError()\ndef __and__(self, other: Filter) -&gt; MultiFilter:\n\"\"\"Combine this filter with another.\"\"\"\nreturn MultiFilter(op=\"and\", filters=(self, other))\ndef __or__(self, other: Filter) -&gt; MultiFilter:\n\"\"\"Combine this filter with another.\"\"\"\nreturn MultiFilter(op=\"or\", filters=(self, other))\ndef __str__(self) -&gt; str:\nreturn str(self.create().compile(compile_kwargs={\"literal_binds\": True}))\n</code></pre>"},{"location":"api/#artigraph.Filter.__and__","title":"__and__","text":"<pre><code>__and__(other: Filter) -&gt; MultiFilter\n</code></pre> <p>Combine this filter with another.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>def __and__(self, other: Filter) -&gt; MultiFilter:\n\"\"\"Combine this filter with another.\"\"\"\nreturn MultiFilter(op=\"and\", filters=(self, other))\n</code></pre>"},{"location":"api/#artigraph.Filter.__or__","title":"__or__","text":"<pre><code>__or__(other: Filter) -&gt; MultiFilter\n</code></pre> <p>Combine this filter with another.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>def __or__(self, other: Filter) -&gt; MultiFilter:\n\"\"\"Combine this filter with another.\"\"\"\nreturn MultiFilter(op=\"or\", filters=(self, other))\n</code></pre>"},{"location":"api/#artigraph.Filter.compose","title":"compose","text":"<pre><code>compose(expr: Expression) -&gt; Expression\n</code></pre> <p>Apply the where clause to the given query.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>def compose(self, expr: Expression, /) -&gt; Expression:\n\"\"\"Apply the where clause to the given query.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.Filter.create","title":"create","text":"<pre><code>create() -&gt; Expression\n</code></pre> <p>Return the condition represented by this filter.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>def create(self) -&gt; Expression:\n\"\"\"Return the condition represented by this filter.\"\"\"\nreturn self.compose(_NO_OP)\n</code></pre>"},{"location":"api/#artigraph.GraphModel","title":"GraphModel","text":"<p>             Bases: <code>GraphObject[OrmModelArtifact, OrmBase, NodeFilter[Any]]</code></p> <p>A base for all modeled artifacts.</p> Source code in <code>src/artigraph/core/model/base.py</code> <pre><code>class GraphModel(GraphObject[OrmModelArtifact, OrmBase, NodeFilter[Any]]):\n\"\"\"A base for all modeled artifacts.\"\"\"\ngraph_id: UUID\n\"\"\"The unique ID of this model.\"\"\"\ngraph_orm_type: ClassVar[type[OrmModelArtifact]] = OrmModelArtifact\n\"\"\"The ORM type for this model.\"\"\"\ngraph_model_name: ClassVar[str]\n\"\"\"The name of the artifact model.\"\"\"\ngraph_model_version: ClassVar[int] = 1\n\"\"\"The version of the artifact model.\"\"\"\ndef graph_model_data(self) -&gt; ModelData:\n\"\"\"The data for the artifact model.\"\"\"\nraise NotImplementedError()\n@classmethod\ndef graph_model_init(\ncls,\ninfo: ModelInfo,  # noqa: ARG003\nkwargs: dict[str, Any],\n/,\n) -&gt; Self:  # nocov\n\"\"\"Initialize the artifact model, migrating it if necessary.\"\"\"\nreturn cls(**kwargs)\ndef __init_subclass__(cls, version: int, **kwargs: Any):\ncls.graph_model_version = version\nif \"graph_model_name\" not in cls.__dict__:\ncls.graph_model_name = cls.__name__\nif not ALLOW_MODEL_TYPE_OVERWRITES.get() and cls.graph_model_name in MODEL_TYPE_BY_NAME:\nmsg = (\nf\"Artifact model {cls.graph_model_name!r} already exists \"\nf\"as {MODEL_TYPE_BY_NAME[cls.graph_model_name]}\"\n)\nraise RuntimeError(msg)\nelse:\nMODEL_TYPE_BY_NAME[cls.graph_model_name] = cls\nsuper().__init_subclass__(**kwargs)\ndef graph_filter_self(self) -&gt; NodeFilter[Any]:\nreturn NodeFilter(id=self.graph_id)\n@classmethod\ndef graph_filter_related(cls, where: NodeFilter[Any]) -&gt; dict[type[OrmBase], Filter]:\nreturn {\nOrmArtifact: NodeFilter(descendant_of=where),\nOrmLink: LinkFilter(ancestor=where),\n}\nasync def graph_dump_self(self) -&gt; OrmModelArtifact:\nmetadata_dict = ModelMetadata(artigraph_version=artigraph_version)\nreturn self._graph_make_own_metadata_artifact(metadata_dict)\nasync def graph_dump_related(self) -&gt; Sequence[OrmBase]:\ndump_related: TaskBatch[Sequence[OrmBase]] = TaskBatch()\nfor label, (value, spec) in self.graph_model_data().items():\nmaybe_model = _try_convert_value_to_modeled_type(value)\nif spec.is_empty() and isinstance(maybe_model, GraphObject):\ndump_related.add(_dump_and_link, maybe_model, self.graph_id, label)\nelse:\nart = spec.create_artifact(value)\ndump_related.add(_dump_and_link, art, self.graph_id, label)\nreturn [r for rs in await dump_related.gather() for r in rs]\n@classmethod\nasync def graph_load(\ncls,\nself_records: Sequence[OrmModelArtifact],\nrelated_records: dict[type[OrmBase], Sequence[OrmBase]],\n) -&gt; Sequence[Self]:\narts_dict_by_p_id = _get_labeled_artifacts_by_source_id(self_records, related_records)\nreturn [\n(\nawait model_type._graph_load_from_labeled_artifacts_by_source_id(\nart, arts_dict_by_p_id\n)\n)\nfor art in self_records\nif issubclass(model_type := get_model_type_by_name(art.model_artifact_type_name), cls)\n]\n@classmethod\nasync def _graph_load_from_labeled_artifacts_by_source_id(\ncls,\nmodel_metadata_artifact: OrmModelArtifact,\nlabeled_artifacts_by_source_id: LabeledArtifactsByParentId,\n) -&gt; Self:\nreturn cls.graph_model_init(\nModelInfo(\ngraph_id=model_metadata_artifact.id,\nversion=model_metadata_artifact.model_artifact_version,\nmetadata=await load_deserialized_artifact_value(model_metadata_artifact),\n),\nawait cls._graph_load_kwargs_from_labeled_artifacts_by_source_id(\nmodel_metadata_artifact,\nlabeled_artifacts_by_source_id,\n),\n)\n@classmethod\nasync def _graph_load_kwargs_from_labeled_artifacts_by_source_id(\ncls,\nmodel_metadata_artifact: OrmModelArtifact,\nlabeled_artifacts_by_source_id: LabeledArtifactsByParentId,\n) -&gt; dict[str, Any]:\nlabeled_children = labeled_artifacts_by_source_id[model_metadata_artifact.id]\nload_field_values: TaskBatch[Any] = TaskBatch()\nfor child in labeled_children.values():\nif isinstance(child, OrmModelArtifact):\nchild_cls = get_model_type_by_name(child.model_artifact_type_name)\nload_field_values.add(\nchild_cls._graph_load_from_labeled_artifacts_by_source_id,\nchild,\nlabeled_artifacts_by_source_id,\n)\nelse:\nload_field_values.add(\nload_deserialized_artifact_value,\nchild,\n)\nreturn dict(zip(labeled_children.keys(), await load_field_values.gather()))\ndef _graph_make_own_metadata_artifact(self, metadata: ModelMetadata) -&gt; OrmModelArtifact:\nreturn OrmModelArtifact(\nid=self.graph_id,\nartifact_serializer=json_sorted_serializer.name,\ndatabase_artifact_data=json_sorted_serializer.serialize(metadata),\nmodel_artifact_type_name=self.graph_model_name,\nmodel_artifact_version=self.graph_model_version,\n)\n</code></pre>"},{"location":"api/#artigraph.GraphModel.graph_id","title":"graph_id  <code>instance-attribute</code>","text":"<pre><code>graph_id: UUID\n</code></pre> <p>The unique ID of this model.</p>"},{"location":"api/#artigraph.GraphModel.graph_model_name","title":"graph_model_name  <code>class-attribute</code>","text":"<pre><code>graph_model_name: str\n</code></pre> <p>The name of the artifact model.</p>"},{"location":"api/#artigraph.GraphModel.graph_model_version","title":"graph_model_version  <code>class-attribute</code>","text":"<pre><code>graph_model_version: int = 1\n</code></pre> <p>The version of the artifact model.</p>"},{"location":"api/#artigraph.GraphModel.graph_orm_type","title":"graph_orm_type  <code>class-attribute</code>","text":"<pre><code>graph_orm_type: type[OrmModelArtifact] = OrmModelArtifact\n</code></pre> <p>The ORM type for this model.</p>"},{"location":"api/#artigraph.GraphModel.graph_model_data","title":"graph_model_data","text":"<pre><code>graph_model_data() -&gt; ModelData\n</code></pre> <p>The data for the artifact model.</p> Source code in <code>src/artigraph/core/model/base.py</code> <pre><code>def graph_model_data(self) -&gt; ModelData:\n\"\"\"The data for the artifact model.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.GraphModel.graph_model_init","title":"graph_model_init  <code>classmethod</code>","text":"<pre><code>graph_model_init(\ninfo: ModelInfo, kwargs: dict[str, Any]\n) -&gt; Self\n</code></pre> <p>Initialize the artifact model, migrating it if necessary.</p> Source code in <code>src/artigraph/core/model/base.py</code> <pre><code>@classmethod\ndef graph_model_init(\ncls,\ninfo: ModelInfo,  # noqa: ARG003\nkwargs: dict[str, Any],\n/,\n) -&gt; Self:  # nocov\n\"\"\"Initialize the artifact model, migrating it if necessary.\"\"\"\nreturn cls(**kwargs)\n</code></pre>"},{"location":"api/#artigraph.GraphObject","title":"GraphObject","text":"<p>             Bases: <code>ABC</code>, <code>Generic[S, R, F]</code></p> <p>Base for objects that can be converted to and from Artigraph ORM records.</p> Source code in <code>src/artigraph/core/api/base.py</code> <pre><code>class GraphObject(abc.ABC, Generic[S, R, F]):\n\"\"\"Base for objects that can be converted to and from Artigraph ORM records.\"\"\"\ngraph_id: UUID\n\"\"\"The ID of the object.\"\"\"\ngraph_orm_type: ClassVar[type[OrmBase]]\n\"\"\"The ORM type that represents this object.\"\"\"\n@abc.abstractmethod\ndef graph_filter_self(self) -&gt; F:\n\"\"\"Get the filter for records of the ORM type that represent the object.\"\"\"\nraise NotImplementedError()\n@abc.abstractmethod\nasync def graph_dump_self(self) -&gt; S:\n\"\"\"Dump the object into an ORM record.\"\"\"\nraise NotImplementedError()\n@abc.abstractmethod\nasync def graph_dump_related(self) -&gt; Sequence[R]:\n\"\"\"Dump all other related objects into ORM records.\"\"\"\nraise NotImplementedError()\n@classmethod\n@abc.abstractmethod\ndef graph_filter_related(cls, self_filter: Filter, /) -&gt; Mapping[type[R], Filter]:\n\"\"\"Get the filters for records of related ORM records required to construct this object.\"\"\"\nraise NotImplementedError()\n@classmethod\n@abc.abstractmethod\nasync def graph_load(\ncls,\nself_records: Sequence[S],\nrelated_records: dict[type[R], Sequence[R]],\n/,\n) -&gt; Sequence[Self]:\n\"\"\"Load ORM records into objects.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.GraphObject.graph_id","title":"graph_id  <code>instance-attribute</code>","text":"<pre><code>graph_id: UUID\n</code></pre> <p>The ID of the object.</p>"},{"location":"api/#artigraph.GraphObject.graph_orm_type","title":"graph_orm_type  <code>class-attribute</code>","text":"<pre><code>graph_orm_type: type[OrmBase]\n</code></pre> <p>The ORM type that represents this object.</p>"},{"location":"api/#artigraph.GraphObject.graph_dump_related","title":"graph_dump_related  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>graph_dump_related() -&gt; Sequence[R]\n</code></pre> <p>Dump all other related objects into ORM records.</p> Source code in <code>src/artigraph/core/api/base.py</code> <pre><code>@abc.abstractmethod\nasync def graph_dump_related(self) -&gt; Sequence[R]:\n\"\"\"Dump all other related objects into ORM records.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.GraphObject.graph_dump_self","title":"graph_dump_self  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>graph_dump_self() -&gt; S\n</code></pre> <p>Dump the object into an ORM record.</p> Source code in <code>src/artigraph/core/api/base.py</code> <pre><code>@abc.abstractmethod\nasync def graph_dump_self(self) -&gt; S:\n\"\"\"Dump the object into an ORM record.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.GraphObject.graph_filter_related","title":"graph_filter_related  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>graph_filter_related(\nself_filter: Filter,\n) -&gt; Mapping[type[R], Filter]\n</code></pre> <p>Get the filters for records of related ORM records required to construct this object.</p> Source code in <code>src/artigraph/core/api/base.py</code> <pre><code>@classmethod\n@abc.abstractmethod\ndef graph_filter_related(cls, self_filter: Filter, /) -&gt; Mapping[type[R], Filter]:\n\"\"\"Get the filters for records of related ORM records required to construct this object.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.GraphObject.graph_filter_self","title":"graph_filter_self  <code>abstractmethod</code>","text":"<pre><code>graph_filter_self() -&gt; F\n</code></pre> <p>Get the filter for records of the ORM type that represent the object.</p> Source code in <code>src/artigraph/core/api/base.py</code> <pre><code>@abc.abstractmethod\ndef graph_filter_self(self) -&gt; F:\n\"\"\"Get the filter for records of the ORM type that represent the object.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.GraphObject.graph_load","title":"graph_load  <code>abstractmethod</code> <code>async</code> <code>classmethod</code>","text":"<pre><code>graph_load(\nself_records: Sequence[S],\nrelated_records: dict[type[R], Sequence[R]],\n) -&gt; Sequence[Self]\n</code></pre> <p>Load ORM records into objects.</p> Source code in <code>src/artigraph/core/api/base.py</code> <pre><code>@classmethod\n@abc.abstractmethod\nasync def graph_load(\ncls,\nself_records: Sequence[S],\nrelated_records: dict[type[R], Sequence[R]],\n/,\n) -&gt; Sequence[Self]:\n\"\"\"Load ORM records into objects.\"\"\"\nraise NotImplementedError()\n</code></pre>"},{"location":"api/#artigraph.JsonSerializer","title":"JsonSerializer","text":"<p>             Bases: <code>Serializer[Any]</code></p> <p>A serializer for JSON.</p> Source code in <code>src/artigraph/core/serializer/json.py</code> <pre><code>class JsonSerializer(Serializer[Any]):\n\"\"\"A serializer for JSON.\"\"\"\ntypes = (object,)\ndef __init__(self, *, sort_keys: bool = False) -&gt; None:\nself.name = f\"artigraph-json-{'sorted' if sort_keys else 'unsorted'}\"\ndef serialize(self, value: Any) -&gt; bytes:\n\"\"\"Serialize a value.\"\"\"\nreturn json.dumps(value, separators=(\",\", \":\"), allow_nan=False).encode(\"utf-8\")\ndef deserialize(self, value: bytes) -&gt; Any:\n\"\"\"Deserialize a value.\"\"\"\nreturn json.loads(value.decode(\"utf-8\"))\n</code></pre>"},{"location":"api/#artigraph.JsonSerializer.deserialize","title":"deserialize","text":"<pre><code>deserialize(value: bytes) -&gt; Any\n</code></pre> <p>Deserialize a value.</p> Source code in <code>src/artigraph/core/serializer/json.py</code> <pre><code>def deserialize(self, value: bytes) -&gt; Any:\n\"\"\"Deserialize a value.\"\"\"\nreturn json.loads(value.decode(\"utf-8\"))\n</code></pre>"},{"location":"api/#artigraph.JsonSerializer.serialize","title":"serialize","text":"<pre><code>serialize(value: Any) -&gt; bytes\n</code></pre> <p>Serialize a value.</p> Source code in <code>src/artigraph/core/serializer/json.py</code> <pre><code>def serialize(self, value: Any) -&gt; bytes:\n\"\"\"Serialize a value.\"\"\"\nreturn json.dumps(value, separators=(\",\", \":\"), allow_nan=False).encode(\"utf-8\")\n</code></pre>"},{"location":"api/#artigraph.Link","title":"Link","text":"<p>             Bases: <code>FrozenDataclass</code>, <code>GraphObject[L, OrmLink, LinkFilter]</code></p> <p>A wrapper around an ORM node link record.</p> Source code in <code>src/artigraph/core/api/link.py</code> <pre><code>class Link(FrozenDataclass, GraphObject[L, OrmLink, LinkFilter]):\n\"\"\"A wrapper around an ORM node link record.\"\"\"\ngraph_orm_type: ClassVar[type[OrmLink]] = OrmLink\n\"\"\"The ORM type for this node.\"\"\"\nsource_id: UUID\n\"\"\"The ID of the parent node.\"\"\"\ntarget_id: UUID\n\"\"\"The ID of the child node.\"\"\"\nlabel: str | None = None\n\"\"\"A label for the link.\"\"\"\ngraph_id: UUID = field(default_factory=uuid1)\n\"\"\"The unique ID of this link\"\"\"\ndef graph_filter_self(self) -&gt; LinkFilter:\nreturn LinkFilter(id=self.graph_id)\n@classmethod\ndef graph_filter_related(cls, _: LinkFilter) -&gt; dict:\nreturn {}\nasync def graph_dump_self(self) -&gt; OrmLink:\nreturn OrmLink(\nid=self.graph_id,\ntarget_id=self.target_id,\nsource_id=self.source_id,\nlabel=self.label,\n)\nasync def graph_dump_related(self) -&gt; Sequence[Any]:\nreturn []\n@classmethod\nasync def graph_load(cls, self_records: Sequence[OrmLink], _: dict) -&gt; Sequence[Self]:\nreturn [\ncls(\ngraph_id=r.id,\ntarget_id=r.target_id,\nsource_id=r.source_id,\nlabel=r.label,\n)\nfor r in self_records\n]\n</code></pre>"},{"location":"api/#artigraph.Link.graph_id","title":"graph_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>graph_id: UUID = field(default_factory=uuid1)\n</code></pre> <p>The unique ID of this link</p>"},{"location":"api/#artigraph.Link.graph_orm_type","title":"graph_orm_type  <code>class-attribute</code>","text":"<pre><code>graph_orm_type: type[OrmLink] = OrmLink\n</code></pre> <p>The ORM type for this node.</p>"},{"location":"api/#artigraph.Link.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: str | None = None\n</code></pre> <p>A label for the link.</p>"},{"location":"api/#artigraph.Link.source_id","title":"source_id  <code>instance-attribute</code>","text":"<pre><code>source_id: UUID\n</code></pre> <p>The ID of the parent node.</p>"},{"location":"api/#artigraph.Link.target_id","title":"target_id  <code>instance-attribute</code>","text":"<pre><code>target_id: UUID\n</code></pre> <p>The ID of the child node.</p>"},{"location":"api/#artigraph.LinkFilter","title":"LinkFilter","text":"<p>             Bases: <code>Filter</code></p> <p>Filter node links.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>class LinkFilter(Filter):\n\"\"\"Filter node links.\"\"\"\nid: ValueFilter[UUID] | UUID | None = None\n\"\"\"Links must have this ID or meet this condition.\"\"\"\nparent: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Links must have one of these nodes as their parent.\"\"\"\nchild: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Links must have one of these nodes as their child.\"\"\"\ndescendant: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Links must have one of these nodes as their descendant.\"\"\"\nancestor: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Links must have one of these nodes as their ancestor.\"\"\"\nlabel: ValueFilter[str] | Sequence[str] | str | None = None\ndef compose(self, expr: Expression) -&gt; Expression:\nlink_id = to_value_filter(self.id)\nsource_id = to_node_id_selector(self.parent)\ntarget_id = to_node_id_selector(self.child)\ndescendant_id = to_node_id_selector(self.descendant)\nancestor_id = to_node_id_selector(self.ancestor)\nlabel = to_value_filter(self.label)\nif link_id is not None:\nexpr &amp;= link_id.against(OrmLink.id).create()\nif source_id is not None:\nexpr &amp;= OrmLink.source_id.in_(source_id)\nif target_id is not None:\nexpr &amp;= OrmLink.target_id.in_(target_id)\nif ancestor_id is not None:\n# Create a CTE to get the descendants recursively\ndescendant_node_cte = (\nselect(OrmLink.source_id.label(\"descendant_id\"), OrmLink.target_id)\n.where(OrmLink.source_id.in_(ancestor_id))\n.cte(name=\"descendants\", recursive=True)\n)\n# Recursive case: select the children of the current nodes\nchild_node = aliased(OrmLink)\ndescendant_node_cte = descendant_node_cte.union_all(\nselect(child_node.source_id, child_node.target_id).where(\nchild_node.source_id == descendant_node_cte.c.target_id\n)\n)\n# Join the CTE with the actual Node table to get the descendants\nexpr &amp;= OrmLink.source_id.in_(\nselect(descendant_node_cte.c.descendant_id).where(\ndescendant_node_cte.c.descendant_id.isnot(None)\n)\n)\nif descendant_id is not None:\n# Create a CTE to get the ancestors recursively\nancestor_node_cte = (\nselect(OrmLink.target_id.label(\"ancestor_id\"), OrmLink.source_id)\n.where(OrmLink.target_id.in_(descendant_id))\n.cte(name=\"ancestors\", recursive=True)\n)\n# Recursive case: select the parents of the current nodes\nparent_node = aliased(OrmLink)\nancestor_node_cte = ancestor_node_cte.union_all(\nselect(parent_node.target_id, parent_node.source_id).where(\nparent_node.target_id == ancestor_node_cte.c.source_id\n)\n)\n# Join the CTE with the actual Node table to get the ancestors\nexpr &amp;= OrmLink.target_id.in_(\nselect(ancestor_node_cte.c.ancestor_id).where(\nancestor_node_cte.c.ancestor_id.isnot(None)\n)\n)\nif label is not None:\nexpr &amp;= label.against(OrmLink.label).create()\nreturn expr\n</code></pre>"},{"location":"api/#artigraph.LinkFilter.ancestor","title":"ancestor  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ancestor: NodeFilter | Sequence[UUID] | UUID | None = None\n</code></pre> <p>Links must have one of these nodes as their ancestor.</p>"},{"location":"api/#artigraph.LinkFilter.child","title":"child  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child: NodeFilter | Sequence[UUID] | UUID | None = None\n</code></pre> <p>Links must have one of these nodes as their child.</p>"},{"location":"api/#artigraph.LinkFilter.descendant","title":"descendant  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>descendant: NodeFilter | Sequence[UUID] | UUID | None = None\n</code></pre> <p>Links must have one of these nodes as their descendant.</p>"},{"location":"api/#artigraph.LinkFilter.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: ValueFilter[UUID] | UUID | None = None\n</code></pre> <p>Links must have this ID or meet this condition.</p>"},{"location":"api/#artigraph.LinkFilter.parent","title":"parent  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent: NodeFilter | Sequence[UUID] | UUID | None = None\n</code></pre> <p>Links must have one of these nodes as their parent.</p>"},{"location":"api/#artigraph.Linker","title":"Linker","text":"<p>             Bases: <code>AnySyncContextManager['Linker']</code></p> <p>A context manager for linking graph objects together</p> Source code in <code>src/artigraph/core/linker.py</code> <pre><code>class Linker(AnySyncContextManager[\"Linker\"]):\n\"\"\"A context manager for linking graph objects together\"\"\"\ndef __init__(self, node: GraphObject, label: str | None = None) -&gt; None:\nself.node = node\nself.label = label\nself._labels: set[str] = set()\nself._write_on_enter: list[GraphObject] = [self.node]\nself._write_on_exit: list[GraphObject] = []\ndef link(\nself,\nvalue: Any,\nlabel: str | None = None,\nstorage: Storage | None = None,\nserializer: Serializer | None = None,\n) -&gt; None:\n\"\"\"Link a graph object to the current node\"\"\"\nif label is not None:\nif label in self._labels:\nmsg = f\"Label {label} already exists for {self.node}\"\nraise ValueError(msg)\nself._labels.add(label)\nif isinstance(value, GraphObject):\ngraph_obj = value\nif storage is not None or serializer is not None:\nmsg = \"Cannot specify storage or serializer when linking a GraphObject\"\nraise ValueError(msg)\nelse:\ngraph_obj = Artifact(value=value, storage=storage, serializer=serializer)\nself._write_on_exit.extend(\n[\ngraph_obj,\nLink(\nsource_id=self.node.graph_id,\ntarget_id=graph_obj.graph_id,\nlabel=label,\n),\n]\n)\nasync def _aenter(self) -&gt; Self:\nawait write_many.a(self._write_on_enter)\nreturn self\nasync def _aexit(self, *_: Any) -&gt; None:\nawait write_many.a(self._write_on_exit)\ndef _enter(self) -&gt; None:\nself.parent = _CURRENT_LINKER.get()\nif self.parent is not None:\nself._write_on_enter.append(\nLink(\nsource_id=self.parent.node.graph_id,\ntarget_id=self.node.graph_id,\nlabel=self.label,\n)\n)\nself._reset_parent = _CURRENT_LINKER.set(self)\ndef _exit(self) -&gt; None:\n_CURRENT_LINKER.reset(self._reset_parent)\n</code></pre>"},{"location":"api/#artigraph.Linker.link","title":"link","text":"<pre><code>link(\nvalue: Any,\nlabel: str | None = None,\nstorage: Storage | None = None,\nserializer: Serializer | None = None,\n) -&gt; None\n</code></pre> <p>Link a graph object to the current node</p> Source code in <code>src/artigraph/core/linker.py</code> <pre><code>def link(\nself,\nvalue: Any,\nlabel: str | None = None,\nstorage: Storage | None = None,\nserializer: Serializer | None = None,\n) -&gt; None:\n\"\"\"Link a graph object to the current node\"\"\"\nif label is not None:\nif label in self._labels:\nmsg = f\"Label {label} already exists for {self.node}\"\nraise ValueError(msg)\nself._labels.add(label)\nif isinstance(value, GraphObject):\ngraph_obj = value\nif storage is not None or serializer is not None:\nmsg = \"Cannot specify storage or serializer when linking a GraphObject\"\nraise ValueError(msg)\nelse:\ngraph_obj = Artifact(value=value, storage=storage, serializer=serializer)\nself._write_on_exit.extend(\n[\ngraph_obj,\nLink(\nsource_id=self.node.graph_id,\ntarget_id=graph_obj.graph_id,\nlabel=label,\n),\n]\n)\n</code></pre>"},{"location":"api/#artigraph.ModelFilter","title":"ModelFilter","text":"<p>             Bases: <code>ArtifactFilter[OrmModelArtifact]</code>, <code>Generic[M]</code></p> <p>A filter for models.</p> Source code in <code>src/artigraph/core/model/filter.py</code> <pre><code>class ModelFilter(ArtifactFilter[OrmModelArtifact], Generic[M]):\n\"\"\"A filter for models.\"\"\"\nnode_type: NodeTypeFilter[OrmModelArtifact] = NodeTypeFilter(type=[OrmModelArtifact])\n\"\"\"Models must be one of these types.\"\"\"\nmodel_type: Sequence[ModelTypeFilter[M]] | ModelTypeFilter[M] | type[M] | None = None\n\"\"\"Models must be one of these types.\"\"\"\ndef compose(self, expr: Expression) -&gt; Expression:\nexpr = super().compose(expr)\nmodel_type = to_sequence_or_none(self.model_type)\nif model_type:\nexpr &amp;= MultiFilter(\nop=\"or\",\nfilters=[_to_model_type_filter(mt) for mt in model_type],\n).create()\nreturn expr\n</code></pre>"},{"location":"api/#artigraph.ModelFilter.model_type","title":"model_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_type: Sequence[ModelTypeFilter[M]] | ModelTypeFilter[\nM\n] | type[M] | None = None\n</code></pre> <p>Models must be one of these types.</p>"},{"location":"api/#artigraph.ModelFilter.node_type","title":"node_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>node_type: NodeTypeFilter[\nOrmModelArtifact\n] = NodeTypeFilter(type=[OrmModelArtifact])\n</code></pre> <p>Models must be one of these types.</p>"},{"location":"api/#artigraph.ModelInfo","title":"ModelInfo  <code>dataclass</code>","text":"<p>The info for an artifact model.</p> Source code in <code>src/artigraph/core/model/base.py</code> <pre><code>@dataclass(frozen=True)\nclass ModelInfo:\n\"\"\"The info for an artifact model.\"\"\"\ngraph_id: UUID\n\"\"\"The unique ID of the artifact model.\"\"\"\nversion: int\n\"\"\"The version of the artifact model.\"\"\"\nmetadata: ModelMetadata\n\"\"\"The metadata for the artifact model\"\"\"\n</code></pre>"},{"location":"api/#artigraph.ModelInfo.graph_id","title":"graph_id  <code>instance-attribute</code>","text":"<pre><code>graph_id: UUID\n</code></pre> <p>The unique ID of the artifact model.</p>"},{"location":"api/#artigraph.ModelInfo.metadata","title":"metadata  <code>instance-attribute</code>","text":"<pre><code>metadata: ModelMetadata\n</code></pre> <p>The metadata for the artifact model</p>"},{"location":"api/#artigraph.ModelInfo.version","title":"version  <code>instance-attribute</code>","text":"<pre><code>version: int\n</code></pre> <p>The version of the artifact model.</p>"},{"location":"api/#artigraph.ModelMetadata","title":"ModelMetadata","text":"<p>             Bases: <code>TypedDict</code></p> <p>The metadata for an artifact model.</p> Source code in <code>src/artigraph/core/model/base.py</code> <pre><code>class ModelMetadata(TypedDict):\n\"\"\"The metadata for an artifact model.\"\"\"\nartigraph_version: str\n\"\"\"The version of Artigraph used to generate the model\"\"\"\n</code></pre>"},{"location":"api/#artigraph.ModelMetadata.artigraph_version","title":"artigraph_version  <code>instance-attribute</code>","text":"<pre><code>artigraph_version: str\n</code></pre> <p>The version of Artigraph used to generate the model</p>"},{"location":"api/#artigraph.ModelTypeFilter","title":"ModelTypeFilter","text":"<p>             Bases: <code>Generic[M]</code>, <code>Filter</code></p> <p>Filter models by their type and version</p> Source code in <code>src/artigraph/core/model/filter.py</code> <pre><code>class ModelTypeFilter(Generic[M], Filter):\n\"\"\"Filter models by their type and version\"\"\"\ntype: type[M]\n\"\"\"Models must be this type.\"\"\"\nversion: ValueFilter | int | None = None\n\"\"\"Models must be this version.\"\"\"\nsubclasses: bool = True\n\"\"\"If True, include subclasses of the given model type.\"\"\"\ndef compose(self, expr: Expression) -&gt; Expression:\nversion = to_value_filter(self.version)\nif self.subclasses:\nexpr &amp;= OrmModelArtifact.model_artifact_type_name.in_(\n[m.graph_model_name for m in get_subclasses(self.type)]\n)\nelse:\nexpr &amp;= OrmModelArtifact.model_artifact_type_name == self.type.graph_model_name\nif version:\nexpr &amp;= version.against(OrmModelArtifact.model_artifact_version).create()\nreturn expr\n</code></pre>"},{"location":"api/#artigraph.ModelTypeFilter.subclasses","title":"subclasses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subclasses: bool = True\n</code></pre> <p>If True, include subclasses of the given model type.</p>"},{"location":"api/#artigraph.ModelTypeFilter.type","title":"type  <code>instance-attribute</code>","text":"<pre><code>type: type[M]\n</code></pre> <p>Models must be this type.</p>"},{"location":"api/#artigraph.ModelTypeFilter.version","title":"version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>version: ValueFilter | int | None = None\n</code></pre> <p>Models must be this version.</p>"},{"location":"api/#artigraph.Node","title":"Node","text":"<p>             Bases: <code>FrozenDataclass</code>, <code>GraphObject[N, OrmLink, NodeFilter[Any]]</code></p> <p>A wrapper around an ORM node record.</p> Source code in <code>src/artigraph/core/api/node.py</code> <pre><code>class Node(FrozenDataclass, GraphObject[N, OrmLink, NodeFilter[Any]]):\n\"\"\"A wrapper around an ORM node record.\"\"\"\ngraph_orm_type: ClassVar[type[OrmNode]] = OrmNode\n\"\"\"The ORM type for this node.\"\"\"\ngraph_id: UUID = field(default_factory=uuid1)\n\"\"\"The unique ID of this node\"\"\"\ndef graph_filter_self(self) -&gt; NodeFilter[Any]:\nreturn NodeFilter(id=self.graph_id)\nasync def graph_dump_self(self) -&gt; OrmNode:\nreturn OrmNode(id=self.graph_id)\nasync def graph_dump_related(self) -&gt; Sequence[Any]:\nreturn []\n@classmethod\ndef graph_filter_related(cls, where: NodeFilter[Any]) -&gt; dict[type[OrmLink], Filter]:\nreturn {OrmLink: LinkFilter(parent=where) | LinkFilter(child=where)}\n@classmethod\nasync def graph_load(\ncls,\nself_records: Sequence[N],\nrelated_records: dict[type[OrmLink], Sequence[OrmLink]],  # noqa: ARG003\n) -&gt; Sequence[Self]:\nreturn [\ncls(\ngraph_id=r.id,\n**(await cls._graph_load_extra_kwargs(r)),\n)\nfor r in self_records\n]\n@classmethod\nasync def _graph_load_extra_kwargs(\ncls,\nself_record: N,  # noqa: ARG003\n) -&gt; dict[str, Any]:\nreturn {}\n</code></pre>"},{"location":"api/#artigraph.Node.graph_id","title":"graph_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>graph_id: UUID = field(default_factory=uuid1)\n</code></pre> <p>The unique ID of this node</p>"},{"location":"api/#artigraph.Node.graph_orm_type","title":"graph_orm_type  <code>class-attribute</code>","text":"<pre><code>graph_orm_type: type[OrmNode] = OrmNode\n</code></pre> <p>The ORM type for this node.</p>"},{"location":"api/#artigraph.NodeFilter","title":"NodeFilter","text":"<p>             Bases: <code>Filter</code>, <code>Generic[N]</code></p> <p>Filter nodes that meet the given conditions</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>class NodeFilter(Filter, Generic[N]):\n\"\"\"Filter nodes that meet the given conditions\"\"\"\nid: ValueFilter[UUID] | Sequence[UUID] | UUID | None = None\n\"\"\"Nodes must have this ID or meet this condition.\"\"\"\nnode_type: NodeTypeFilter[N] | type[N] | None = None\n\"\"\"Nodes must be one of these types.\"\"\"\ncreated_at: ValueFilter[datetime] | datetime | None = None\n\"\"\"Filter nodes by their creation time.\"\"\"\nupdated_at: ValueFilter[datetime] | datetime | None = None\n\"\"\"Filter nodes by their last update time.\"\"\"\nparent_of: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Nodes must be the parent of one of these nodes.\"\"\"\nchild_of: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Nodes must be the child of one of these nodes.\"\"\"\ndescendant_of: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Nodes must be the descendant of one of these nodes.\"\"\"\nancestor_of: NodeFilter | Sequence[UUID] | UUID | None = None\n\"\"\"Nodes must be the ancestor of one of these nodes.\"\"\"\nlabel: ValueFilter[str] | Sequence[str] | str | None = None\n\"\"\"Nodes must have a link with one of these labels.\"\"\"\ndef compose(self, expr: Expression) -&gt; Expression:\nnode_id = to_value_filter(self.id)\ncreated_at = to_value_filter(self.created_at)\nupdated_at = to_value_filter(self.updated_at)\nif node_id is not None:\nexpr &amp;= node_id.against(OrmNode.id).create()\nif self.node_type is not None:\nexpr &amp;= (\nself.node_type\nif isinstance(self.node_type, NodeTypeFilter)\nelse NodeTypeFilter(type=[self.node_type])\n).create()\nif created_at:\nexpr &amp;= created_at.against(OrmNode.created_at).create()\nif updated_at:\nexpr &amp;= updated_at.against(OrmNode.updated_at).create()\nif self.parent_of or self.ancestor_of:\nexpr &amp;= OrmNode.id.in_(\nselect(OrmLink.source_id).where(\nLinkFilter(child=self.parent_of, descendant=self.ancestor_of).create()\n)\n)\nif self.child_of or self.descendant_of:\nexpr &amp;= OrmNode.id.in_(\nselect(OrmLink.target_id).where(\nLinkFilter(parent=self.child_of, ancestor=self.descendant_of).create()\n)\n)\nif self.label:\nexpr &amp;= OrmNode.id.in_(\nselect(OrmLink.target_id).where(LinkFilter(label=self.label).create())\n)\nreturn expr\n</code></pre>"},{"location":"api/#artigraph.NodeFilter.ancestor_of","title":"ancestor_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ancestor_of: NodeFilter | Sequence[\nUUID\n] | UUID | None = None\n</code></pre> <p>Nodes must be the ancestor of one of these nodes.</p>"},{"location":"api/#artigraph.NodeFilter.child_of","title":"child_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>child_of: NodeFilter | Sequence[UUID] | UUID | None = None\n</code></pre> <p>Nodes must be the child of one of these nodes.</p>"},{"location":"api/#artigraph.NodeFilter.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: ValueFilter[datetime] | datetime | None = None\n</code></pre> <p>Filter nodes by their creation time.</p>"},{"location":"api/#artigraph.NodeFilter.descendant_of","title":"descendant_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>descendant_of: NodeFilter | Sequence[\nUUID\n] | UUID | None = None\n</code></pre> <p>Nodes must be the descendant of one of these nodes.</p>"},{"location":"api/#artigraph.NodeFilter.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: ValueFilter[UUID] | Sequence[UUID] | UUID | None = None\n</code></pre> <p>Nodes must have this ID or meet this condition.</p>"},{"location":"api/#artigraph.NodeFilter.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: ValueFilter[str] | Sequence[str] | str | None = None\n</code></pre> <p>Nodes must have a link with one of these labels.</p>"},{"location":"api/#artigraph.NodeFilter.node_type","title":"node_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>node_type: NodeTypeFilter[N] | type[N] | None = None\n</code></pre> <p>Nodes must be one of these types.</p>"},{"location":"api/#artigraph.NodeFilter.parent_of","title":"parent_of  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>parent_of: NodeFilter | Sequence[UUID] | UUID | None = None\n</code></pre> <p>Nodes must be the parent of one of these nodes.</p>"},{"location":"api/#artigraph.NodeFilter.updated_at","title":"updated_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated_at: ValueFilter[datetime] | datetime | None = None\n</code></pre> <p>Filter nodes by their last update time.</p>"},{"location":"api/#artigraph.NodeTypeFilter","title":"NodeTypeFilter","text":"<p>             Bases: <code>Filter</code>, <code>Generic[N]</code></p> <p>Filter nodes by their type.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>class NodeTypeFilter(Filter, Generic[N]):\n\"\"\"Filter nodes by their type.\"\"\"\nsubclasses: bool = True\n\"\"\"Consider subclasses of the given types when filtering.\"\"\"\ntype: Sequence[type[N]] | type[N] | None = None\n\"\"\"Nodes must be one of these types.\"\"\"\nnot_type: Sequence[type[N]] | type[N] | None = None\n\"\"\"Nodes must not be one of these types.\"\"\"\ndef compose(self, expr: Expression) -&gt; Expression:\ntype_in = to_sequence_or_none(self.type)\ntype_not_in = to_sequence_or_none(self.not_type)\nif type_in is not None:\npolys_in = get_polymorphic_identities(type_in, subclasses=self.subclasses)\nexpr &amp;= OrmNode.node_type.in_(polys_in)\nif type_not_in is not None:\npolys_not_in = get_polymorphic_identities(type_not_in, subclasses=self.subclasses)\nexpr &amp;= OrmNode.node_type.notin_(polys_not_in)\nreturn expr\n</code></pre>"},{"location":"api/#artigraph.NodeTypeFilter.not_type","title":"not_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>not_type: Sequence[type[N]] | type[N] | None = None\n</code></pre> <p>Nodes must not be one of these types.</p>"},{"location":"api/#artigraph.NodeTypeFilter.subclasses","title":"subclasses  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>subclasses: bool = True\n</code></pre> <p>Consider subclasses of the given types when filtering.</p>"},{"location":"api/#artigraph.NodeTypeFilter.type","title":"type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>type: Sequence[type[N]] | type[N] | None = None\n</code></pre> <p>Nodes must be one of these types.</p>"},{"location":"api/#artigraph.OrmArtifact","title":"OrmArtifact","text":"<p>             Bases: <code>OrmNode</code></p> <p>A base class for artifacts.</p> Source code in <code>src/artigraph/core/orm/artifact.py</code> <pre><code>class OrmArtifact(OrmNode):\n\"\"\"A base class for artifacts.\"\"\"\n__table_args__ = (UniqueConstraint(\"node_source_id\", \"artifact_label\"),)\n__mapper_args__: ClassVar[dict[str, Any]] = {\"polymorphic_abstract\": True}\nartifact_serializer: Mapped[str | None] = mapped_column(index=True)\n\"\"\"The name of the serializer used to serialize the artifact.\"\"\"\n</code></pre>"},{"location":"api/#artigraph.OrmArtifact.artifact_serializer","title":"artifact_serializer  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>artifact_serializer: Mapped[str | None] = mapped_column(\nindex=True\n)\n</code></pre> <p>The name of the serializer used to serialize the artifact.</p>"},{"location":"api/#artigraph.OrmBase","title":"OrmBase","text":"<p>             Bases: <code>MappedAsDataclass</code>, <code>DeclarativeBase</code></p> <p>A base class for all database models.</p> Source code in <code>src/artigraph/core/orm/base.py</code> <pre><code>class OrmBase(MappedAsDataclass, DeclarativeBase):\n\"\"\"A base class for all database models.\"\"\"\n__mapper_args__: ClassVar[dict[str, Any]] = {}\n_: KW_ONLY\ndef __init_subclass__(cls, **kwargs: Any) -&gt; None:\nsuper().__init_subclass__(**kwargs)\ntablename = getattr(cls, \"__tablename__\", None)\nif not tablename:  # nocov\nreturn\nif not cls.__mapper_args__.get(\"polymorphic_abstract\"):\npoly_id = cls.__mapper_args__.get(\"polymorphic_identity\")\nif poly_id is not None:\nt_and_p = (cls.__tablename__, poly_id)\nmaybe_conflict_cls = _ORM_TYPE_BY_TABLE_AND_POLY_ID.setdefault(t_and_p, cls)\nif cls is not maybe_conflict_cls:  # nocov\nmsg = f\"Polymorphic ID {poly_id} exists as {maybe_conflict_cls}\"\nraise ValueError(msg)\nrank = 0\nfor c in inspect(cls).columns:\nfor fk in c.foreign_keys:\ntry:\ncol = fk.column\nexcept NoReferencedTableError as e:  # nocov\nmsg = \"Artigraph does not support deferred foreign keys at this time.\"\nraise RuntimeError(msg) from e\nif col.table.name != tablename:\nother_rank = _FK_DEPENDENCY_RANK_BY_TABLE_NAME[fk.column.table.name] + 1\nrank = max(rank, other_rank)\n_FK_DEPENDENCY_RANK_BY_TABLE_NAME[tablename] = rank\ncreated_at: Mapped[datetime] = mapped_column(\nnullable=False,\ndefault_factory=func.now,\ninit=False,\n)\n\"\"\"The time that this node link was created.\"\"\"\nupdated_at: Mapped[datetime] = mapped_column(\nnullable=False,\ndefault_factory=func.now,\nonupdate=func.now(),\ninit=False,\n)\n\"\"\"The time that this node link was last updated.\"\"\"\n</code></pre>"},{"location":"api/#artigraph.OrmBase.created_at","title":"created_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>created_at: Mapped[datetime] = mapped_column(\nnullable=False, default_factory=func.now, init=False\n)\n</code></pre> <p>The time that this node link was created.</p>"},{"location":"api/#artigraph.OrmBase.updated_at","title":"updated_at  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>updated_at: Mapped[datetime] = mapped_column(\nnullable=False,\ndefault_factory=func.now,\nonupdate=func.now(),\ninit=False,\n)\n</code></pre> <p>The time that this node link was last updated.</p>"},{"location":"api/#artigraph.OrmDatabaseArtifact","title":"OrmDatabaseArtifact","text":"<p>             Bases: <code>OrmArtifact</code></p> <p>An artifact saved directly in the database.</p> Source code in <code>src/artigraph/core/orm/artifact.py</code> <pre><code>class OrmDatabaseArtifact(OrmArtifact):\n\"\"\"An artifact saved directly in the database.\"\"\"\npolymorphic_identity = \"database_artifact\"\n__mapper_args__: ClassVar[dict[str, Any]] = {\"polymorphic_identity\": polymorphic_identity}\ndatabase_artifact_data: Mapped[bytes | None]\n\"\"\"The data of the artifact.\"\"\"\n</code></pre>"},{"location":"api/#artigraph.OrmDatabaseArtifact.database_artifact_data","title":"database_artifact_data  <code>instance-attribute</code>","text":"<pre><code>database_artifact_data: Mapped[bytes | None]\n</code></pre> <p>The data of the artifact.</p>"},{"location":"api/#artigraph.OrmLink","title":"OrmLink","text":"<p>             Bases: <code>OrmBase</code></p> <p>A link between two nodes.</p> Source code in <code>src/artigraph/core/orm/link.py</code> <pre><code>class OrmLink(OrmBase):\n\"\"\"A link between two nodes.\"\"\"\n__tablename__ = \"artigraph_link\"\n__table_args__ = (\nUniqueConstraint(\"source_id\", \"target_id\"),\nUniqueConstraint(\"source_id\", \"label\"),\n)\nid: Mapped[UUID] = mapped_column(primary_key=True)\n\"\"\"The ID of the link.\"\"\"\ntarget_id: Mapped[UUID] = mapped_column(ForeignKey(OrmNode.id), nullable=False, index=True)\n\"\"\"The ID of the node to which this link points.\"\"\"\nsource_id: Mapped[UUID] = mapped_column(ForeignKey(OrmNode.id), nullable=False, index=True)\n\"\"\"The ID of the node from which this link originates.\"\"\"\nlabel: Mapped[str | None] = mapped_column(nullable=True, default=None, index=True)\n\"\"\"A label for the link - labels must be unique for a given source node.\"\"\"\n</code></pre>"},{"location":"api/#artigraph.OrmLink.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Mapped[UUID] = mapped_column(primary_key=True)\n</code></pre> <p>The ID of the link.</p>"},{"location":"api/#artigraph.OrmLink.label","title":"label  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>label: Mapped[str | None] = mapped_column(\nnullable=True, default=None, index=True\n)\n</code></pre> <p>A label for the link - labels must be unique for a given source node.</p>"},{"location":"api/#artigraph.OrmLink.source_id","title":"source_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>source_id: Mapped[UUID] = mapped_column(\nForeignKey(OrmNode.id), nullable=False, index=True\n)\n</code></pre> <p>The ID of the node from which this link originates.</p>"},{"location":"api/#artigraph.OrmLink.target_id","title":"target_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>target_id: Mapped[UUID] = mapped_column(\nForeignKey(OrmNode.id), nullable=False, index=True\n)\n</code></pre> <p>The ID of the node to which this link points.</p>"},{"location":"api/#artigraph.OrmModelArtifact","title":"OrmModelArtifact","text":"<p>             Bases: <code>OrmDatabaseArtifact</code></p> <p>An artifact that is a model.</p> Source code in <code>src/artigraph/core/orm/artifact.py</code> <pre><code>class OrmModelArtifact(OrmDatabaseArtifact):\n\"\"\"An artifact that is a model.\"\"\"\npolymorphic_identity = \"model_artifact\"\n__mapper_args__: ClassVar[dict[str, Any]] = {\"polymorphic_identity\": polymorphic_identity}\nmodel_artifact_type_name: Mapped[str] = mapped_column(nullable=True, index=True)\n\"\"\"The type of the model.\"\"\"\nmodel_artifact_version: Mapped[int] = mapped_column(nullable=True, index=True)\n\"\"\"The version of the model.\"\"\"\n</code></pre>"},{"location":"api/#artigraph.OrmModelArtifact.model_artifact_type_name","title":"model_artifact_type_name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_artifact_type_name: Mapped[str] = mapped_column(\nnullable=True, index=True\n)\n</code></pre> <p>The type of the model.</p>"},{"location":"api/#artigraph.OrmModelArtifact.model_artifact_version","title":"model_artifact_version  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>model_artifact_version: Mapped[int] = mapped_column(\nnullable=True, index=True\n)\n</code></pre> <p>The version of the model.</p>"},{"location":"api/#artigraph.OrmNode","title":"OrmNode","text":"<p>             Bases: <code>OrmBase</code></p> <p>A base class for describing a node in a graph.</p> Source code in <code>src/artigraph/core/orm/node.py</code> <pre><code>class OrmNode(OrmBase, **_node_dataclass_kwargs):\n\"\"\"A base class for describing a node in a graph.\"\"\"\ndef __init_subclass__(cls, **kwargs: Any) -&gt; None:\ncls._shuttle_table_args()\ncls._set_polymorphic_identity()\nsuper().__init_subclass__(**kwargs)\n@classmethod\ndef is_abstract(cls) -&gt; bool:\n\"\"\"Returns True if the class is abstract. That is, it defines a polymorphic identity.\"\"\"\nreturn \"polymorphic_identity\" not in cls.__dict__\npolymorphic_identity: ClassVar[str] = \"node\"\n\"\"\"The type of the node - should be overridden by subclasses and passed to mapper args.\"\"\"\n__tablename__ = \"artigraph_node\"\n__mapper_args__: ClassVar[dict[str, Any]] = {\n\"polymorphic_identity\": polymorphic_identity,\n\"polymorphic_on\": \"node_type\",\n}\nid: Mapped[UUID] = mapped_column(primary_key=True)\n\"\"\"The unique ID of this node\"\"\"\nnode_type: Mapped[str] = mapped_column(nullable=False, init=False, index=True)\n\"\"\"The type of the node link.\"\"\"\n@classmethod\ndef _shuttle_table_args(cls: type[OrmNode]) -&gt; None:\n\"\"\"Transfer table args from non-table subclasses to the base which has a table.\n        This method exists because __table_args__ cannot be define on subclasses without\n        a __tablename__. Since we're using single table inheritance this effectively means\n        subclasses cannot specify __table_args__. To work around this, we transfer the\n        any __table_args__ defined on a subclass to the first base that has a __tablename__\n        (which is Node) before SQLAlchemy complains.\n        \"\"\"\nif \"__table_args__\" in cls.__dict__:\ntable_args = cls.__table_args__\nfor parent_cls in cls.mro():  # nocov (this)\nif hasattr(parent_cls, \"__tablename__\"):\ncls.__table_args__ += table_args\nbreak\ndel cls.__table_args__\n@classmethod\ndef _set_polymorphic_identity(cls: type[OrmNode]) -&gt; None:\n\"\"\"Sets a polymorphic identity attribute on the class for easier use.\"\"\"\npoly_id: str\nfor c in cls.mro():\nmapper_args = getattr(c, \"__mapper_args__\", {})\nif \"polymorphic_identity\" in mapper_args:\npoly_id = mapper_args[\"polymorphic_identity\"]\nbreak\nelse:  # nocov\nmsg = \"No polymorphic_identity found in mro\"\nraise TypeError(msg)\nif poly_id != cls.polymorphic_identity:\nmsg = (\nf\"polymorphic_identity class attribute {cls.polymorphic_identity!r} \"\nf\"does not match value from __mapper_args__ {poly_id!r}\"\n)\nraise ValueError(msg)\n</code></pre>"},{"location":"api/#artigraph.OrmNode.id","title":"id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>id: Mapped[UUID] = mapped_column(primary_key=True)\n</code></pre> <p>The unique ID of this node</p>"},{"location":"api/#artigraph.OrmNode.node_type","title":"node_type  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>node_type: Mapped[str] = mapped_column(\nnullable=False, init=False, index=True\n)\n</code></pre> <p>The type of the node link.</p>"},{"location":"api/#artigraph.OrmNode.polymorphic_identity","title":"polymorphic_identity  <code>class-attribute</code>","text":"<pre><code>polymorphic_identity: str = 'node'\n</code></pre> <p>The type of the node - should be overridden by subclasses and passed to mapper args.</p>"},{"location":"api/#artigraph.OrmNode.is_abstract","title":"is_abstract  <code>classmethod</code>","text":"<pre><code>is_abstract() -&gt; bool\n</code></pre> <p>Returns True if the class is abstract. That is, it defines a polymorphic identity.</p> Source code in <code>src/artigraph/core/orm/node.py</code> <pre><code>@classmethod\ndef is_abstract(cls) -&gt; bool:\n\"\"\"Returns True if the class is abstract. That is, it defines a polymorphic identity.\"\"\"\nreturn \"polymorphic_identity\" not in cls.__dict__\n</code></pre>"},{"location":"api/#artigraph.OrmRemoteArtifact","title":"OrmRemoteArtifact","text":"<p>             Bases: <code>OrmArtifact</code></p> <p>An artifact saved via a storage backend.</p> Source code in <code>src/artigraph/core/orm/artifact.py</code> <pre><code>class OrmRemoteArtifact(OrmArtifact):\n\"\"\"An artifact saved via a storage backend.\"\"\"\npolymorphic_identity = \"remote_artifact\"\n__mapper_args__: ClassVar[dict[str, Any]] = {\"polymorphic_identity\": polymorphic_identity}\nremote_artifact_storage: Mapped[str] = mapped_column(nullable=True, index=True)\n\"\"\"The name of the storage method for the artifact.\"\"\"\nremote_artifact_location: Mapped[str] = mapped_column(nullable=True, index=True)\n\"\"\"A string describing where the artifact is stored.\"\"\"\n</code></pre>"},{"location":"api/#artigraph.OrmRemoteArtifact.remote_artifact_location","title":"remote_artifact_location  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>remote_artifact_location: Mapped[str] = mapped_column(\nnullable=True, index=True\n)\n</code></pre> <p>A string describing where the artifact is stored.</p>"},{"location":"api/#artigraph.OrmRemoteArtifact.remote_artifact_storage","title":"remote_artifact_storage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>remote_artifact_storage: Mapped[str] = mapped_column(\nnullable=True, index=True\n)\n</code></pre> <p>The name of the storage method for the artifact.</p>"},{"location":"api/#artigraph.SaveSpec","title":"SaveSpec  <code>dataclass</code>","text":"<p>Information about how to save an artifact.</p> Source code in <code>src/artigraph/core/api/artifact.py</code> <pre><code>@dataclass(frozen=True)\nclass SaveSpec:\n\"\"\"Information about how to save an artifact.\"\"\"\nserializers: Sequence[Serializer] = ()\n\"\"\"The serializers to try when saving the artifact.\"\"\"\nstorage: Storage | None = None\n\"\"\"The storage to use when saving the artifact.\"\"\"\ndef is_empty(self) -&gt; bool:\n\"\"\"Return whether this save spec is empty.\"\"\"\nreturn not self.serializers and self.storage is None\ndef create_artifact(self, value: T, *, strict: bool = False) -&gt; Artifact[T]:\n\"\"\"Create an artifact from a value.\"\"\"\nif isinstance(value, bytes):\nreturn Artifact(value=value, serializer=None, storage=self.storage)\nfor s in self.serializers:\nif isinstance(value, s.types):\nreturn Artifact(value=value, serializer=s, storage=self.storage)\nif strict:\nif not self.serializers:\nmsg = f\"No serializers specified for {value!r}\"\nraise ValueError(msg)\nallowed_types = \", \".join([t.__name__ for s in self.serializers for t in s.types])\nmsg = f\"Expected {allowed_types} - got {value!r}\"\nraise TypeError(msg)\nserializer = get_serializer_by_type(type(value))[0]\nreturn Artifact(value=value, serializer=serializer, storage=self.storage)\n</code></pre>"},{"location":"api/#artigraph.SaveSpec.serializers","title":"serializers  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>serializers: Sequence[Serializer] = ()\n</code></pre> <p>The serializers to try when saving the artifact.</p>"},{"location":"api/#artigraph.SaveSpec.storage","title":"storage  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>storage: Storage | None = None\n</code></pre> <p>The storage to use when saving the artifact.</p>"},{"location":"api/#artigraph.SaveSpec.create_artifact","title":"create_artifact","text":"<pre><code>create_artifact(\nvalue: T, *, strict: bool = False\n) -&gt; Artifact[T]\n</code></pre> <p>Create an artifact from a value.</p> Source code in <code>src/artigraph/core/api/artifact.py</code> <pre><code>def create_artifact(self, value: T, *, strict: bool = False) -&gt; Artifact[T]:\n\"\"\"Create an artifact from a value.\"\"\"\nif isinstance(value, bytes):\nreturn Artifact(value=value, serializer=None, storage=self.storage)\nfor s in self.serializers:\nif isinstance(value, s.types):\nreturn Artifact(value=value, serializer=s, storage=self.storage)\nif strict:\nif not self.serializers:\nmsg = f\"No serializers specified for {value!r}\"\nraise ValueError(msg)\nallowed_types = \", \".join([t.__name__ for s in self.serializers for t in s.types])\nmsg = f\"Expected {allowed_types} - got {value!r}\"\nraise TypeError(msg)\nserializer = get_serializer_by_type(type(value))[0]\nreturn Artifact(value=value, serializer=serializer, storage=self.storage)\n</code></pre>"},{"location":"api/#artigraph.SaveSpec.is_empty","title":"is_empty","text":"<pre><code>is_empty() -&gt; bool\n</code></pre> <p>Return whether this save spec is empty.</p> Source code in <code>src/artigraph/core/api/artifact.py</code> <pre><code>def is_empty(self) -&gt; bool:\n\"\"\"Return whether this save spec is empty.\"\"\"\nreturn not self.serializers and self.storage is None\n</code></pre>"},{"location":"api/#artigraph.Serializer","title":"Serializer","text":"<p>             Bases: <code>ABC</code>, <code>Generic[T]</code></p> <p>A type of artifact that can be serialized to a string or bytes.</p> Source code in <code>src/artigraph/core/serializer/base.py</code> <pre><code>class Serializer(ABC, Generic[T]):\n\"\"\"A type of artifact that can be serialized to a string or bytes.\"\"\"\nname: str\n\"\"\"A globally unique name for this serializer.\n    This will typically be of the form \"library_name.SerializerName\". You should avoid\n    using dynamic values like `__name__` or `__qualname__` as these may change between\n    versions of the library or if you move the class to a different module.\n    The serializer name will be used to recover this class from a when deserializing\n    artifacts so it must not change between versions of the library. If you need to\n    change the name, you should create and register a subclass with the new name and\n    deprecate the old one.\n    \"\"\"\ntypes: tuple[type[T], ...]\n\"\"\"The types of values this serializer supports.\"\"\"\ndef register(self) -&gt; Self:\n\"\"\"Register a serializer.\n        It's recommended that each serializer be defined and registerd in a separate module\n        so that users can select which serializers they want to use by importing the module.\n        Thus if a user does not import a serializer if will not be registered. This is\n        important for two reasons:\n        1. It allows users to avoid importing dependencies they don't need.\n        2. Serializers that supprt the same type will override each other - only the last one\n        registered will be used unless the user explicitly selects one.\n        \"\"\"\nif not isinstance(self, Serializer):  # nocov\nmsg = f\"{self} is not of Serializer\"\nraise ValueError(msg)\nif self.name in SERIALIZERS_BY_NAME:\nmsg = f\"Serializer named {self.name!r} already registered.\"\nraise ValueError(msg)\nSERIALIZERS_BY_NAME[self.name] = self\nfor t in self.types:\nSERIALIZERS_BY_TYPE[t] = (*SERIALIZERS_BY_TYPE.get(t, ()), self)\nreturn self\n@abstractmethod\ndef serialize(self, value: T, /) -&gt; bytes:\n\"\"\"Serialize a value to a string or bytes.\"\"\"\nraise NotImplementedError()  # nocov\n@abstractmethod\ndef deserialize(self, value: bytes, /) -&gt; T:\n\"\"\"Deserialize a string or bytes to a value.\"\"\"\nraise NotImplementedError()  # nocov\n</code></pre>"},{"location":"api/#artigraph.Serializer.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>A globally unique name for this serializer.</p> <p>This will typically be of the form \"library_name.SerializerName\". You should avoid using dynamic values like <code>__name__</code> or <code>__qualname__</code> as these may change between versions of the library or if you move the class to a different module.</p> <p>The serializer name will be used to recover this class from a when deserializing artifacts so it must not change between versions of the library. If you need to change the name, you should create and register a subclass with the new name and deprecate the old one.</p>"},{"location":"api/#artigraph.Serializer.types","title":"types  <code>instance-attribute</code>","text":"<pre><code>types: tuple[type[T], ...]\n</code></pre> <p>The types of values this serializer supports.</p>"},{"location":"api/#artigraph.Serializer.deserialize","title":"deserialize  <code>abstractmethod</code>","text":"<pre><code>deserialize(value: bytes) -&gt; T\n</code></pre> <p>Deserialize a string or bytes to a value.</p> Source code in <code>src/artigraph/core/serializer/base.py</code> <pre><code>@abstractmethod\ndef deserialize(self, value: bytes, /) -&gt; T:\n\"\"\"Deserialize a string or bytes to a value.\"\"\"\nraise NotImplementedError()  # nocov\n</code></pre>"},{"location":"api/#artigraph.Serializer.register","title":"register","text":"<pre><code>register() -&gt; Self\n</code></pre> <p>Register a serializer.</p> <p>It's recommended that each serializer be defined and registerd in a separate module so that users can select which serializers they want to use by importing the module. Thus if a user does not import a serializer if will not be registered. This is important for two reasons:</p> <ol> <li>It allows users to avoid importing dependencies they don't need.</li> <li>Serializers that supprt the same type will override each other - only the last one registered will be used unless the user explicitly selects one.</li> </ol> Source code in <code>src/artigraph/core/serializer/base.py</code> <pre><code>def register(self) -&gt; Self:\n\"\"\"Register a serializer.\n    It's recommended that each serializer be defined and registerd in a separate module\n    so that users can select which serializers they want to use by importing the module.\n    Thus if a user does not import a serializer if will not be registered. This is\n    important for two reasons:\n    1. It allows users to avoid importing dependencies they don't need.\n    2. Serializers that supprt the same type will override each other - only the last one\n    registered will be used unless the user explicitly selects one.\n    \"\"\"\nif not isinstance(self, Serializer):  # nocov\nmsg = f\"{self} is not of Serializer\"\nraise ValueError(msg)\nif self.name in SERIALIZERS_BY_NAME:\nmsg = f\"Serializer named {self.name!r} already registered.\"\nraise ValueError(msg)\nSERIALIZERS_BY_NAME[self.name] = self\nfor t in self.types:\nSERIALIZERS_BY_TYPE[t] = (*SERIALIZERS_BY_TYPE.get(t, ()), self)\nreturn self\n</code></pre>"},{"location":"api/#artigraph.Serializer.serialize","title":"serialize  <code>abstractmethod</code>","text":"<pre><code>serialize(value: T) -&gt; bytes\n</code></pre> <p>Serialize a value to a string or bytes.</p> Source code in <code>src/artigraph/core/serializer/base.py</code> <pre><code>@abstractmethod\ndef serialize(self, value: T, /) -&gt; bytes:\n\"\"\"Serialize a value to a string or bytes.\"\"\"\nraise NotImplementedError()  # nocov\n</code></pre>"},{"location":"api/#artigraph.Storage","title":"Storage","text":"<p>             Bases: <code>ABC</code></p> <p>A storage backend for artifacts.</p> Source code in <code>src/artigraph/core/storage/base.py</code> <pre><code>class Storage(ABC):\n\"\"\"A storage backend for artifacts.\"\"\"\nname: str\n\"\"\"A globally unique name for this storage.\n    This will typically be of the form \"library_name-storage_name\". You should avoid\n    using dynamic values like `__name__` or `__qualname__` as these may change between\n    versions of the library or if you move the class to a different module.\n    The storage name will be used to recover this class when loading data from records.\n    It must not change between versions of the library. If you need to change the name,\n    you should create and register a subclass with the new name and deprecate the old\n    one.\n    \"\"\"\ndef register(self) -&gt; Self:\n\"\"\"Register a storage backend.\n        It's recommended that each storage backend be defined and registerd in a separate\n        module so that users can select which storage they want to use by importing the module.\n        Thus, if a user does not import a storage backend it will not be registered. This is\n        important because some storage backends may have dependencies that are not installed.\n        \"\"\"\nif self.name in STORAGE_BY_NAME:\nmsg = (\nf\"Serializer named {self.name!r} already \"\nf\"registered as {STORAGE_BY_NAME[self.name]!r}\"\n)\nraise ValueError(msg)\nSTORAGE_BY_NAME[self.name] = self\nreturn self\n@abstractmethod\nasync def create(self, data: bytes, /) -&gt; str:\n\"\"\"Create the artifact data and return its location.\"\"\"\n...\n@abstractmethod\nasync def read(self, location: str, /) -&gt; bytes:\n\"\"\"Read artifact data from the given location.\"\"\"\n...\n@abstractmethod\nasync def update(self, location: str, data: bytes, /) -&gt; None:\n\"\"\"Update artifact data at the given location.\"\"\"\n...\n@abstractmethod\nasync def delete(self, location: str, /) -&gt; None:\n\"\"\"Delete artifact data at the given location.\"\"\"\n...\n@abstractmethod\nasync def exists(self, location: str, /) -&gt; bool:\n\"\"\"Check if artifact data exists at the given location.\"\"\"\n...\n</code></pre>"},{"location":"api/#artigraph.Storage.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str\n</code></pre> <p>A globally unique name for this storage.</p> <p>This will typically be of the form \"library_name-storage_name\". You should avoid using dynamic values like <code>__name__</code> or <code>__qualname__</code> as these may change between versions of the library or if you move the class to a different module.</p> <p>The storage name will be used to recover this class when loading data from records. It must not change between versions of the library. If you need to change the name, you should create and register a subclass with the new name and deprecate the old one.</p>"},{"location":"api/#artigraph.Storage.create","title":"create  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>create(data: bytes) -&gt; str\n</code></pre> <p>Create the artifact data and return its location.</p> Source code in <code>src/artigraph/core/storage/base.py</code> <pre><code>@abstractmethod\nasync def create(self, data: bytes, /) -&gt; str:\n\"\"\"Create the artifact data and return its location.\"\"\"\n...\n</code></pre>"},{"location":"api/#artigraph.Storage.delete","title":"delete  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>delete(location: str) -&gt; None\n</code></pre> <p>Delete artifact data at the given location.</p> Source code in <code>src/artigraph/core/storage/base.py</code> <pre><code>@abstractmethod\nasync def delete(self, location: str, /) -&gt; None:\n\"\"\"Delete artifact data at the given location.\"\"\"\n...\n</code></pre>"},{"location":"api/#artigraph.Storage.exists","title":"exists  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>exists(location: str) -&gt; bool\n</code></pre> <p>Check if artifact data exists at the given location.</p> Source code in <code>src/artigraph/core/storage/base.py</code> <pre><code>@abstractmethod\nasync def exists(self, location: str, /) -&gt; bool:\n\"\"\"Check if artifact data exists at the given location.\"\"\"\n...\n</code></pre>"},{"location":"api/#artigraph.Storage.read","title":"read  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>read(location: str) -&gt; bytes\n</code></pre> <p>Read artifact data from the given location.</p> Source code in <code>src/artigraph/core/storage/base.py</code> <pre><code>@abstractmethod\nasync def read(self, location: str, /) -&gt; bytes:\n\"\"\"Read artifact data from the given location.\"\"\"\n...\n</code></pre>"},{"location":"api/#artigraph.Storage.register","title":"register","text":"<pre><code>register() -&gt; Self\n</code></pre> <p>Register a storage backend.</p> <p>It's recommended that each storage backend be defined and registerd in a separate module so that users can select which storage they want to use by importing the module. Thus, if a user does not import a storage backend it will not be registered. This is important because some storage backends may have dependencies that are not installed.</p> Source code in <code>src/artigraph/core/storage/base.py</code> <pre><code>def register(self) -&gt; Self:\n\"\"\"Register a storage backend.\n    It's recommended that each storage backend be defined and registerd in a separate\n    module so that users can select which storage they want to use by importing the module.\n    Thus, if a user does not import a storage backend it will not be registered. This is\n    important because some storage backends may have dependencies that are not installed.\n    \"\"\"\nif self.name in STORAGE_BY_NAME:\nmsg = (\nf\"Serializer named {self.name!r} already \"\nf\"registered as {STORAGE_BY_NAME[self.name]!r}\"\n)\nraise ValueError(msg)\nSTORAGE_BY_NAME[self.name] = self\nreturn self\n</code></pre>"},{"location":"api/#artigraph.Storage.update","title":"update  <code>abstractmethod</code> <code>async</code>","text":"<pre><code>update(location: str, data: bytes) -&gt; None\n</code></pre> <p>Update artifact data at the given location.</p> Source code in <code>src/artigraph/core/storage/base.py</code> <pre><code>@abstractmethod\nasync def update(self, location: str, data: bytes, /) -&gt; None:\n\"\"\"Update artifact data at the given location.\"\"\"\n...\n</code></pre>"},{"location":"api/#artigraph.ValueFilter","title":"ValueFilter","text":"<p>             Bases: <code>Filter</code>, <code>Generic[T]</code></p> <p>Filter a column by comparing it to a value.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>class ValueFilter(Filter, Generic[T]):\n\"\"\"Filter a column by comparing it to a value.\"\"\"\ncolumn: InstrumentedAttribute[T] | None = field(repr=False, default=None)\n\"\"\"The column to filter.\"\"\"\ngt: T | None = column_op(default=None, op=operator.gt)\n\"\"\"The column must be greater than this value.\"\"\"\nge: T | None = column_op(default=None, op=operator.ge)\n\"\"\"The column must be greater than or equal to this value.\"\"\"\nlt: T | None = column_op(default=None, op=operator.lt)\n\"\"\"The column must be less than this value.\"\"\"\nle: T | None = column_op(default=None, op=operator.le)\n\"\"\"The column must be less than or equal to this value.\"\"\"\nne: T | None = column_op(default=None, op=operator.ne)\n\"\"\"The column must not be equal to this value.\"\"\"\neq: T | None = column_op(default=None, op=operator.eq)\n\"\"\"The column must be equal to this value.\"\"\"\nin_: Collection[T] | None = column_op(default=None, op=Column.in_)\n\"\"\"The column must be one of these values.\"\"\"\nnot_in: Collection[T] | None = column_op(default=None, op=Column.notin_)\n\"\"\"The column must not be one of these values.\"\"\"\nlike: T | None = column_op(default=None, op=Column.like)\n\"\"\"The column must match this pattern.\"\"\"\nilike: T | None = column_op(default=None, op=Column.ilike)\n\"\"\"The column must match this pattern, case-insensitive.\"\"\"\nis_: bool | None = column_op(default=None, op=Column.is_)\n\"\"\"The column must be this value.\"\"\"\nis_not: bool | None = column_op(default=None, op=Column.isnot)\n\"\"\"The column must not be this value.\"\"\"\ndef against(self, column: InstrumentedAttribute[T] | InstrumentedAttribute[T | None]) -&gt; Self:\n\"\"\"Filter against the given column.\"\"\"\nreturn replace(self, column=column)\ndef compose(self, expr: Expression) -&gt; Expression:\n# InstrumentedAttribute is a descriptor so the type checker thinks\n# self.column is of type T, not InstrumentedAttribute[T]\ncolumn = cast(InstrumentedAttribute[T] | None, self.column)\nif column is None:  # nocov\nmsg = \"No column to filter against - did you forget to call `against`?\"\nraise ValueError(msg)\nfor f in fields(self):\nif \"op\" in f.metadata:\nop_value = getattr(self, f.name, None)\nif op_value is not None:\nop: Callable[[InstrumentedAttribute[T], T], BinaryExpression] = f.metadata[\"op\"]\nexpr &amp;= op(column, op_value)\nreturn expr\n</code></pre>"},{"location":"api/#artigraph.ValueFilter.column","title":"column  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>column: InstrumentedAttribute[T] | None = field(\nrepr=False, default=None\n)\n</code></pre> <p>The column to filter.</p>"},{"location":"api/#artigraph.ValueFilter.eq","title":"eq  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>eq: T | None = column_op(default=None, op=operator.eq)\n</code></pre> <p>The column must be equal to this value.</p>"},{"location":"api/#artigraph.ValueFilter.ge","title":"ge  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ge: T | None = column_op(default=None, op=operator.ge)\n</code></pre> <p>The column must be greater than or equal to this value.</p>"},{"location":"api/#artigraph.ValueFilter.gt","title":"gt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gt: T | None = column_op(default=None, op=operator.gt)\n</code></pre> <p>The column must be greater than this value.</p>"},{"location":"api/#artigraph.ValueFilter.ilike","title":"ilike  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ilike: T | None = column_op(default=None, op=Column.ilike)\n</code></pre> <p>The column must match this pattern, case-insensitive.</p>"},{"location":"api/#artigraph.ValueFilter.in_","title":"in_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>in_: Collection[T] | None = column_op(\ndefault=None, op=Column.in_\n)\n</code></pre> <p>The column must be one of these values.</p>"},{"location":"api/#artigraph.ValueFilter.is_","title":"is_  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_: bool | None = column_op(default=None, op=Column.is_)\n</code></pre> <p>The column must be this value.</p>"},{"location":"api/#artigraph.ValueFilter.is_not","title":"is_not  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>is_not: bool | None = column_op(\ndefault=None, op=Column.isnot\n)\n</code></pre> <p>The column must not be this value.</p>"},{"location":"api/#artigraph.ValueFilter.le","title":"le  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>le: T | None = column_op(default=None, op=operator.le)\n</code></pre> <p>The column must be less than or equal to this value.</p>"},{"location":"api/#artigraph.ValueFilter.like","title":"like  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>like: T | None = column_op(default=None, op=Column.like)\n</code></pre> <p>The column must match this pattern.</p>"},{"location":"api/#artigraph.ValueFilter.lt","title":"lt  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lt: T | None = column_op(default=None, op=operator.lt)\n</code></pre> <p>The column must be less than this value.</p>"},{"location":"api/#artigraph.ValueFilter.ne","title":"ne  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ne: T | None = column_op(default=None, op=operator.ne)\n</code></pre> <p>The column must not be equal to this value.</p>"},{"location":"api/#artigraph.ValueFilter.not_in","title":"not_in  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>not_in: Collection[T] | None = column_op(\ndefault=None, op=Column.notin_\n)\n</code></pre> <p>The column must not be one of these values.</p>"},{"location":"api/#artigraph.ValueFilter.against","title":"against","text":"<pre><code>against(\ncolumn: InstrumentedAttribute[T]\n| InstrumentedAttribute[T | None],\n) -&gt; Self\n</code></pre> <p>Filter against the given column.</p> Source code in <code>src/artigraph/core/api/filter.py</code> <pre><code>def against(self, column: InstrumentedAttribute[T] | InstrumentedAttribute[T | None]) -&gt; Self:\n\"\"\"Filter against the given column.\"\"\"\nreturn replace(self, column=column)\n</code></pre>"},{"location":"api/#artigraph.current_engine","title":"current_engine","text":"<pre><code>current_engine(\nengine: AsyncEngine | str,\n*,\ncreate_tables: bool = False\n) -&gt; Iterator[AsyncEngine]\n</code></pre> <p>Define which engine to use in the context.</p> Source code in <code>src/artigraph/core/db.py</code> <pre><code>@contextmanager\ndef current_engine(\nengine: AsyncEngine | str,\n*,\ncreate_tables: bool = False,\n) -&gt; Iterator[AsyncEngine]:\n\"\"\"Define which engine to use in the context.\"\"\"\nengine = create_async_engine(engine) if isinstance(engine, str) else engine\nreset = set_engine(engine, create_tables=create_tables)\ntry:\nyield engine\nfinally:\nreset()\n</code></pre>"},{"location":"api/#artigraph.current_linker","title":"current_linker","text":"<pre><code>current_linker() -&gt; Linker\n</code></pre> <p>Get the current linker</p> Source code in <code>src/artigraph/core/linker.py</code> <pre><code>def current_linker() -&gt; Linker:\n\"\"\"Get the current linker\"\"\"\nlinker = _CURRENT_LINKER.get()\nif linker is None:  # nocov\nmsg = \"No linker is currently active\"\nraise RuntimeError(msg)\nreturn linker\n</code></pre>"},{"location":"api/#artigraph.current_session","title":"current_session","text":"<pre><code>current_session(\nsession_maker: async_sessionmaker[AsyncSession]\n| None = None,\n) -&gt; AsyncContextManager[AsyncSession]\n</code></pre> <p>A context manager for an asynchronous database session.</p> Source code in <code>src/artigraph/core/db.py</code> <pre><code>def current_session(\nsession_maker: async_sessionmaker[AsyncSession] | None = None,\n) -&gt; AsyncContextManager[AsyncSession]:\n\"\"\"A context manager for an asynchronous database session.\"\"\"\nreturn _CurrentSession(session_maker)\n</code></pre>"},{"location":"api/#artigraph.dataclass","title":"dataclass","text":"<pre><code>dataclass(\ncls: type[T] | None = None, **kwargs: Any\n) -&gt; type[T] | Callable[[type[T]], type[T]]\n</code></pre> <p>A decorator that makes a class into a dataclass GraphModel.</p> <p>See: dataclass</p> Source code in <code>src/artigraph/core/model/dataclasses.py</code> <pre><code>@dataclass_transform(field_specifiers=(field,))\ndef dataclass(cls: type[T] | None = None, **kwargs: Any) -&gt; type[T] | Callable[[type[T]], type[T]]:\n\"\"\"A decorator that makes a class into a dataclass GraphModel.\n    See: [dataclass](https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass)\n    \"\"\"\ndef decorator(cls: type[T]) -&gt; type[T]:\nif not issubclass(cls, GraphModel):\nmsg = f\"{cls} does not inherit from GraphModel\"\nraise TypeError(msg)\ncls = _dataclass(cls, **kwargs)\nwith allow_model_type_overwrites():\n@_dataclass(**kwargs)\nclass _DataclassModel(cls, version=cls.graph_model_version):\ngraph_id: UUID = field(default_factory=uuid1, init=False, compare=False)\ngraph_model_name = getattr(cls, \"graph_model_name\", cls.__name__)\n@classmethod\ndef graph_model_init(cls, info: ModelInfo, data: dict[str, Any]) -&gt; Self:\nself = cls(**data)\nobject.__setattr__(self, \"graph_id\", info.graph_id)\nreturn self\ndef graph_model_data(self) -&gt; ModelData:\nreturn get_annotated_model_data(\nself,\n[\nf.name\nfor f in fields(self)\nif f.init\n# exclude this since it's on the DB record anyway\nand f.name != \"graph_id\"\n],\n)\n_DataclassModel.__name__ = cls.__name__\n_DataclassModel.__qualname__ = cls.__qualname__\nreturn cast(type[T], _DataclassModel)\nreturn decorator if cls is None else decorator(cls)\n</code></pre>"},{"location":"api/#artigraph.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(cls: type[GraphObject], where: Filter) -&gt; None\n</code></pre> <p>Delete records matching the given filter.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def delete(cls: type[GraphObject], where: Filter) -&gt; None:\n\"\"\"Delete records matching the given filter.\"\"\"\nrelated_filters = cls.graph_filter_related(where)\nasync with current_session():\nfor o_type in sorted(related_filters, key=get_fk_dependency_rank, reverse=True):\nawait orm_delete(o_type, related_filters[o_type])\n# must delete this last since the related deletion queries may depend on it\nawait orm_delete(cls.graph_orm_type, where)\n</code></pre>"},{"location":"api/#artigraph.delete_many","title":"delete_many  <code>async</code>","text":"<pre><code>delete_many(objs: Sequence[GraphObject]) -&gt; None\n</code></pre> <p>Delete records.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def delete_many(objs: Sequence[GraphObject]) -&gt; None:\n\"\"\"Delete records.\"\"\"\nfilters_by_type: defaultdict[type[GraphObject], list[Filter]] = defaultdict(list)\nfor o in objs:\nfilters_by_type[type(o)].append(o.graph_filter_self())\nasync with current_session() as session:\nfor o_type, o_filters in filters_by_type.items():\nwhere = o_filters[0] if len(o_filters) == 1 else MultiFilter(op=\"or\", filters=o_filters)\nawait delete.a(o_type, where)\nawait session.commit()\n</code></pre>"},{"location":"api/#artigraph.delete_one","title":"delete_one  <code>async</code>","text":"<pre><code>delete_one(obj: GraphObject) -&gt; None\n</code></pre> <p>Delete a record.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def delete_one(obj: GraphObject) -&gt; None:\n\"\"\"Delete a record.\"\"\"\nreturn await delete_many.a([obj])\n</code></pre>"},{"location":"api/#artigraph.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(cls: type[GraphObject], where: Filter) -&gt; bool\n</code></pre> <p>Check if records exist.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def exists(cls: type[GraphObject], where: Filter) -&gt; bool:\n\"\"\"Check if records exist.\"\"\"\nreturn await orm_exists(cls.graph_orm_type, where)\n</code></pre>"},{"location":"api/#artigraph.get_polymorphic_identities","title":"get_polymorphic_identities","text":"<pre><code>get_polymorphic_identities(\nnode_types: Sequence[type[OrmNode]],\n*,\nsubclasses: bool = False\n) -&gt; Sequence[str]\n</code></pre> <p>Get the polymorphic identities of the given node types and optionall their subclasses.</p> Source code in <code>src/artigraph/core/orm/node.py</code> <pre><code>def get_polymorphic_identities(\nnode_types: Sequence[type[OrmNode]],\n*,\nsubclasses: bool = False,\n) -&gt; Sequence[str]:\n\"\"\"Get the polymorphic identities of the given node types and optionall their subclasses.\"\"\"\nnode_types = [s for c in node_types for s in get_subclasses(c)] if subclasses else node_types\nreturn [nt.polymorphic_identity for nt in node_types if not nt.is_abstract()]\n</code></pre>"},{"location":"api/#artigraph.get_serializer_by_name","title":"get_serializer_by_name","text":"<pre><code>get_serializer_by_name(name: str) -&gt; Serializer[Any]\n</code></pre> <p>Get a serializer by name.</p> Source code in <code>src/artigraph/core/serializer/base.py</code> <pre><code>def get_serializer_by_name(name: str) -&gt; Serializer[Any]:\n\"\"\"Get a serializer by name.\"\"\"\nif name not in SERIALIZERS_BY_NAME:  # nocov\nmsg = f\"No serializer named {name!r}\"\nraise ValueError(msg)\nreturn SERIALIZERS_BY_NAME[name]\n</code></pre>"},{"location":"api/#artigraph.get_serializer_by_type","title":"get_serializer_by_type","text":"<pre><code>get_serializer_by_type(\ncls: type[T],\n) -&gt; Sequence[Serializer[T]]\n</code></pre> <p>Get a serializer by type.</p> Source code in <code>src/artigraph/core/serializer/base.py</code> <pre><code>def get_serializer_by_type(cls: type[T]) -&gt; Sequence[Serializer[T]]:\n\"\"\"Get a serializer by type.\"\"\"\nfor c in cls.mro():\nif c in SERIALIZERS_BY_TYPE:\nreturn SERIALIZERS_BY_TYPE[c]\nmsg = f\"No serializer for type {cls!r}\"  # nocov\nraise ValueError(msg)  # nocov\n</code></pre>"},{"location":"api/#artigraph.linked","title":"linked","text":"<pre><code>linked(\n*,\nnode_type: Callable[[], Node] = Node,\nis_method: bool = False,\ninclude: str | Collection[str] = (),\nexclude: str | Collection[str] = ()\n) -&gt; Callable[[F], F]\n</code></pre> <p>Capture the inputs and outputs of a function using Artigraph</p> Source code in <code>src/artigraph/core/linker.py</code> <pre><code>def linked(\n*,\nnode_type: Callable[[], Node] = Node,\nis_method: bool = False,\ninclude: str | Collection[str] = (),\nexclude: str | Collection[str] = (),\n) -&gt; Callable[[F], F]:\n\"\"\"Capture the inputs and outputs of a function using Artigraph\"\"\"\nif include and exclude:  # nocov\nmsg = \"Cannot specify both only_save and do_not_save\"\nraise ValueError(msg)\ninclude = {include} if isinstance(include, str) else set(include)\nexclude = {exclude} if isinstance(exclude, str) else set(exclude)\ncall_id = 0\ndef decorator(func: F) -&gt; F:\nsig = signature(func)\nhint_info = get_save_specs_from_type_hints(func)\ndef _create_label_and_inputs(args, kwargs):\nnonlocal call_id\ncall_id += 1\nfull_label = f\"{func.__qualname__}[{call_id}]\"\nbound_args = sig.bind_partial(*args, **kwargs)\ninputs = {\nk: v\nfor i, (k, v) in enumerate(bound_args.arguments.items())\nif not is_method or i &gt; 1\n}\nreturn full_label, inputs\nif iscoroutinefunction(func):\n@wraps(func)\nasync def async_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\n# Check that there's an active linker. Without one, it's possible to\n# produce orphaned nodes. It seems better to prevent that.\ncurrent_linker()\nlabel, inputs = _create_label_and_inputs(args, kwargs)\nasync with Linker(node_type(), label) as linker:\noutput = await func(*args, **kwargs)\nvalues = {\"return\": output, **inputs}\nfor k, v in _create_graph_objects(\nvalues,\nhint_info,\ninclude,\nexclude,\n).items():\nlinker.link(v, k)\nreturn output\nreturn cast(F, async_wrapper)\nelif isfunction(func):\n@wraps(func)\ndef sync_wrapper(*args: Any, **kwargs: Any) -&gt; Any:\nnonlocal call_id\n# Check that there's an active linker. Without one, it's possible to\n# produce orphaned nodes. It seems better to prevent that.\ncurrent_linker()\ncall_id += 1\nlabel, inputs = _create_label_and_inputs(args, kwargs)\nwith Linker(node_type(), label) as linker:\noutput = func(*args, **kwargs)\nvalues = {\"return\": output, **inputs}\nfor k, v in _create_graph_objects(\nvalues,\nhint_info,\ninclude,\nexclude,\n).items():\nlinker.link(v, k)\nreturn output\nreturn cast(F, sync_wrapper)\nelse:  # nocov\nmsg = f\"Expected a function, got {type(func)}\"\nraise TypeError(msg)\nreturn decorator\n</code></pre>"},{"location":"api/#artigraph.load_deserialized_artifact_value","title":"load_deserialized_artifact_value  <code>async</code>","text":"<pre><code>load_deserialized_artifact_value(obj: OrmArtifact) -&gt; Any\n</code></pre> <p>Load the value of an artifact from its ORM record.</p> Source code in <code>src/artigraph/core/api/artifact.py</code> <pre><code>async def load_deserialized_artifact_value(obj: OrmArtifact) -&gt; Any:\n\"\"\"Load the value of an artifact from its ORM record.\"\"\"\nif isinstance(obj, OrmRemoteArtifact):\nstorage = get_storage_by_name(obj.remote_artifact_storage)\ndata = await storage.read(obj.remote_artifact_location)\nelif isinstance(obj, OrmDatabaseArtifact):\ndata = obj.database_artifact_data\nstorage = None\nelse:  # nocov\nmsg = f\"Unknown artifact type: {obj}\"\nraise RuntimeError(msg)\nif data is not None and obj.artifact_serializer is not None:\ndata = get_serializer_by_name(obj.artifact_serializer).deserialize(data)\nreturn data\n</code></pre>"},{"location":"api/#artigraph.load_extras","title":"load_extras","text":"<pre><code>load_extras(*names: str) -&gt; None\n</code></pre> <p>Load extra modules.</p> <p>This is useful for registering serializers from 3rd party libraries.</p> Source code in <code>src/artigraph/extras/__init__.py</code> <pre><code>def load_extras(*names: str) -&gt; None:  # nocov\n\"\"\"Load extra modules.\n    This is useful for registering serializers from 3rd party libraries.\n    \"\"\"\ninvalid = set(names).difference(_MODULE_NAMES)\nif invalid:\nmsg = f\"Invalid module names: {invalid}\"\nraise ValueError(msg)\nfor n in names or _MODULE_NAMES:\ntry:\nimport_module(f\"artigraph.extras.{n}\")\nexcept ImportError:\nif names:\nraise\n_logger.debug(f\"Failed to load artigraph.extras.{n}\", exc_info=True)\n</code></pre>"},{"location":"api/#artigraph.read","title":"read  <code>async</code>","text":"<pre><code>read(cls: type[G], where: Filter) -&gt; Sequence[G]\n</code></pre> <p>Read records that match the given filter.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def read(cls: type[G], where: Filter) -&gt; Sequence[G]:\n\"\"\"Read records that match the given filter.\"\"\"\nrecords = await orm_read(cls.graph_orm_type, where)\nrelated_records = {\ngraph_orm_type: await orm_read(graph_orm_type, api_filter)\nfor graph_orm_type, api_filter in cls.graph_filter_related(where).items()\n}\nreturn await cls.graph_load(records, related_records)\n</code></pre>"},{"location":"api/#artigraph.read_one","title":"read_one  <code>async</code>","text":"<pre><code>read_one(cls: type[G], where: Filter) -&gt; G\n</code></pre> <p>Read a record that matches the given filter.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def read_one(cls: type[G], where: Filter) -&gt; G:\n\"\"\"Read a record that matches the given filter.\"\"\"\none = await read_one_or_none.a(cls, where)\nif one is None:\nmsg = f\"No record found matching filter {where}\"\nraise ValueError(msg)\nreturn one\n</code></pre>"},{"location":"api/#artigraph.read_one_or_none","title":"read_one_or_none  <code>async</code>","text":"<pre><code>read_one_or_none(cls: type[G], where: Filter) -&gt; G | None\n</code></pre> <p>Read a record that matches the given filter or None if no record is found.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def read_one_or_none(cls: type[G], where: Filter) -&gt; G | None:\n\"\"\"Read a record that matches the given filter or None if no record is found.\"\"\"\nrecord = await orm_read_one_or_none(cls.graph_orm_type, where)\nif record is None:\nreturn None\nrelated_records = {\ngraph_orm_type: await orm_read(graph_orm_type, related_filter)\nfor graph_orm_type, related_filter in cls.graph_filter_related(where).items()\n}\nreturn cast(G, (await cls.graph_load([record], related_records))[0])\n</code></pre>"},{"location":"api/#artigraph.set_engine","title":"set_engine","text":"<pre><code>set_engine(\nengine: AsyncEngine | str,\n*,\ncreate_tables: bool = False\n) -&gt; Callable[[], None]\n</code></pre> <p>Set the current engine and whether to try creating tables if they don't exist.</p> <p>Tables are only created when the engine is retrieved for the first time.</p> Source code in <code>src/artigraph/core/db.py</code> <pre><code>def set_engine(engine: AsyncEngine | str, *, create_tables: bool = False) -&gt; Callable[[], None]:\n\"\"\"Set the current engine and whether to try creating tables if they don't exist.\n    Tables are only created when the engine is retrieved for the first time.\n    \"\"\"\nengine = create_async_engine(engine) if isinstance(engine, str) else engine\ncurrent_engine_token = _CURRENT_ENGINE.set(engine)\ncreate_tables_token = _CREATE_TABLES.set(create_tables)\ndef reset() -&gt; None:\n_CURRENT_ENGINE.reset(current_engine_token)\n_CREATE_TABLES.reset(create_tables_token)\nreturn reset\n</code></pre>"},{"location":"api/#artigraph.write_many","title":"write_many  <code>async</code>","text":"<pre><code>write_many(objs: Collection[GraphObject]) -&gt; None\n</code></pre> <p>Create records and, if given, refresh their attributes.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def write_many(objs: Collection[GraphObject]) -&gt; None:\n\"\"\"Create records and, if given, refresh their attributes.\"\"\"\nawait orm_write(await dump(objs))\n</code></pre>"},{"location":"api/#artigraph.write_one","title":"write_one  <code>async</code>","text":"<pre><code>write_one(obj: GraphObject) -&gt; None\n</code></pre> <p>Create a record.</p> Source code in <code>src/artigraph/core/api/funcs.py</code> <pre><code>@anysync\nasync def write_one(obj: GraphObject) -&gt; None:\n\"\"\"Create a record.\"\"\"\nreturn await write_many.a([obj])\n</code></pre>"},{"location":"api/#artigraph.extras.aws.S3Storage","title":"S3Storage","text":"<p>             Bases: <code>Storage</code></p> <p>S3 storage backend for Artigraph.</p> <p>Parameters:</p> Name Type Description Default <code>bucket</code> <code>str</code> <p>The name of the S3 bucket.</p> required <code>prefix</code> <code>str</code> <p>The prefix to use for all S3 keys.</p> <code>''</code> <code>s3_client</code> <code>BaseClient</code> <p>The S3 client to use.</p> required Source code in <code>src/artigraph/extras/aws.py</code> <pre><code>class S3Storage(Storage):\n\"\"\"S3 storage backend for Artigraph.\n    Parameters:\n        bucket: The name of the S3 bucket.\n        prefix: The prefix to use for all S3 keys.\n        s3_client: The S3 client to use.\n    \"\"\"\ndef __init__(self, bucket: str, prefix: str = \"\", *, s3_client: BaseClient) -&gt; None:\nself.name = slugify(f\"artigraph-s3-{bucket}-{prefix}\")\nself.bucket = bucket\nself.prefix = prefix\nself.client = s3_client\nasync def create(self, value: bytes) -&gt; str:\n\"\"\"Create an S3 object and return is key.\"\"\"\nhashed_value = hashlib.sha512(value).hexdigest()\nkey = f\"{self.prefix}/{hashed_value}\"\n# Only create the object if it doesn't already exist.\ntry:\nawait run_in_thread(self.client.head_object, Bucket=self.bucket, Key=key)\nexcept ClientError as error:\nif error.response[\"Error\"][\"Code\"] != \"404\":\nraise  # nocov\nawait run_in_thread(self.client.put_object, Bucket=self.bucket, Key=key, Body=value)\nreturn key\nasync def read(self, key: str) -&gt; bytes:\n\"\"\"Read an S3 object.\"\"\"\nresponse = await run_in_thread(self.client.get_object, Bucket=self.bucket, Key=key)\nreturn cast(bytes, response[\"Body\"].read())\nasync def update(self, key: str, value: bytes) -&gt; None:\n\"\"\"Update an S3 object.\"\"\"\nawait run_in_thread(self.client.put_object, Bucket=self.bucket, Key=key, Body=value)\nasync def delete(self, key: str) -&gt; None:\n\"\"\"Delete an S3 object.\"\"\"\nawait run_in_thread(self.client.delete_object, Bucket=self.bucket, Key=key)\nasync def exists(self, key: str) -&gt; bool:\n\"\"\"Check if an S3 object exists.\"\"\"\ntry:\nawait run_in_thread(self.client.head_object, Bucket=self.bucket, Key=key)\nexcept ClientError as error:\nif error.response[\"Error\"][\"Code\"] == \"404\":\nreturn False\nraise  # nocov\nreturn True\n</code></pre>"},{"location":"api/#artigraph.extras.aws.S3Storage.create","title":"create  <code>async</code>","text":"<pre><code>create(value: bytes) -&gt; str\n</code></pre> <p>Create an S3 object and return is key.</p> Source code in <code>src/artigraph/extras/aws.py</code> <pre><code>async def create(self, value: bytes) -&gt; str:\n\"\"\"Create an S3 object and return is key.\"\"\"\nhashed_value = hashlib.sha512(value).hexdigest()\nkey = f\"{self.prefix}/{hashed_value}\"\n# Only create the object if it doesn't already exist.\ntry:\nawait run_in_thread(self.client.head_object, Bucket=self.bucket, Key=key)\nexcept ClientError as error:\nif error.response[\"Error\"][\"Code\"] != \"404\":\nraise  # nocov\nawait run_in_thread(self.client.put_object, Bucket=self.bucket, Key=key, Body=value)\nreturn key\n</code></pre>"},{"location":"api/#artigraph.extras.aws.S3Storage.delete","title":"delete  <code>async</code>","text":"<pre><code>delete(key: str) -&gt; None\n</code></pre> <p>Delete an S3 object.</p> Source code in <code>src/artigraph/extras/aws.py</code> <pre><code>async def delete(self, key: str) -&gt; None:\n\"\"\"Delete an S3 object.\"\"\"\nawait run_in_thread(self.client.delete_object, Bucket=self.bucket, Key=key)\n</code></pre>"},{"location":"api/#artigraph.extras.aws.S3Storage.exists","title":"exists  <code>async</code>","text":"<pre><code>exists(key: str) -&gt; bool\n</code></pre> <p>Check if an S3 object exists.</p> Source code in <code>src/artigraph/extras/aws.py</code> <pre><code>async def exists(self, key: str) -&gt; bool:\n\"\"\"Check if an S3 object exists.\"\"\"\ntry:\nawait run_in_thread(self.client.head_object, Bucket=self.bucket, Key=key)\nexcept ClientError as error:\nif error.response[\"Error\"][\"Code\"] == \"404\":\nreturn False\nraise  # nocov\nreturn True\n</code></pre>"},{"location":"api/#artigraph.extras.aws.S3Storage.read","title":"read  <code>async</code>","text":"<pre><code>read(key: str) -&gt; bytes\n</code></pre> <p>Read an S3 object.</p> Source code in <code>src/artigraph/extras/aws.py</code> <pre><code>async def read(self, key: str) -&gt; bytes:\n\"\"\"Read an S3 object.\"\"\"\nresponse = await run_in_thread(self.client.get_object, Bucket=self.bucket, Key=key)\nreturn cast(bytes, response[\"Body\"].read())\n</code></pre>"},{"location":"api/#artigraph.extras.aws.S3Storage.update","title":"update  <code>async</code>","text":"<pre><code>update(key: str, value: bytes) -&gt; None\n</code></pre> <p>Update an S3 object.</p> Source code in <code>src/artigraph/extras/aws.py</code> <pre><code>async def update(self, key: str, value: bytes) -&gt; None:\n\"\"\"Update an S3 object.\"\"\"\nawait run_in_thread(self.client.put_object, Bucket=self.bucket, Key=key, Body=value)\n</code></pre>"},{"location":"api/#artigraph.extras.networkx.create_graph","title":"create_graph  <code>async</code>","text":"<pre><code>create_graph(root: GraphObject) -&gt; nx.DiGraph\n</code></pre> <p>Create a NetworkX graph from an Artigraph node.</p> Source code in <code>src/artigraph/extras/networkx.py</code> <pre><code>@anysync\nasync def create_graph(root: GraphObject) -&gt; nx.DiGraph:\n\"\"\"Create a NetworkX graph from an Artigraph node.\"\"\"\nnodes_by_id, relationship, labels = await _read_nodes_relationships_labels(root)\ngraph = nx.DiGraph()\nfor i, n in _dfs_iter_nodes(root, list(nodes_by_id.values()), relationship):\ngraph.add_node(i, obj=n, label=labels.get(i))\ngraph.add_edges_from(\n[\n(source, target, {\"label\": labels[target]})\nfor source, targets in relationship.items()\nfor target in targets\n]\n)\nfor layer, nodes in enumerate(nx.topological_generations(graph)):\n# `multipartite_layout` expects the layer as a node attribute, so add the\n# numeric layer value as a node attribute\nfor node in nodes:\ngraph.nodes[node][\"subset\"] = layer\nreturn graph\n</code></pre>"},{"location":"api/#artigraph.extras.numpy.array_serializer","title":"array_serializer  <code>module-attribute</code>","text":"<pre><code>array_serializer = ArraySerializer().register()\n</code></pre> <p>A serializer for numpy arrays.</p>"},{"location":"api/#artigraph.extras.numpy.ArraySerializer","title":"ArraySerializer","text":"<p>             Bases: <code>Serializer[ndarray]</code></p> <p>A serializer for numpy arrays.</p> Source code in <code>src/artigraph/extras/numpy.py</code> <pre><code>class ArraySerializer(Serializer[np.ndarray]):\n\"\"\"A serializer for numpy arrays.\"\"\"\ntypes = (np.ndarray,)\nname = \"artigraph-numpy\"\n@staticmethod\ndef serialize(value: np.ndarray) -&gt; bytes:\n\"\"\"Serialize a numpy array.\"\"\"\nif len(value.shape) == NP_1D_SHAPE_LEN:\npd_value = pd.DataFrame({\"1darray\": value})\nelif len(value.shape) == NP_2D_SHAPE_LEN:\npd_value = pd.DataFrame(dict(enumerate(value.T)))\nelse:\nmsg = f\"Can only serialize 1D or 2D arrays, not {value.shape}.\"\nraise ValueError(msg)\nreturn dataframe_serializer.serialize(pd_value)\n@staticmethod\ndef deserialize(value: bytes) -&gt; np.ndarray:\n\"\"\"Deserialize a numpy array.\"\"\"\npd_value = dataframe_serializer.deserialize(value)\nif \"1darray\" in pd_value.columns:\nreturn pd_value[\"1darray\"].to_numpy()\nreturn pd_value.to_numpy()\n</code></pre>"},{"location":"api/#artigraph.extras.numpy.ArraySerializer.deserialize","title":"deserialize  <code>staticmethod</code>","text":"<pre><code>deserialize(value: bytes) -&gt; np.ndarray\n</code></pre> <p>Deserialize a numpy array.</p> Source code in <code>src/artigraph/extras/numpy.py</code> <pre><code>@staticmethod\ndef deserialize(value: bytes) -&gt; np.ndarray:\n\"\"\"Deserialize a numpy array.\"\"\"\npd_value = dataframe_serializer.deserialize(value)\nif \"1darray\" in pd_value.columns:\nreturn pd_value[\"1darray\"].to_numpy()\nreturn pd_value.to_numpy()\n</code></pre>"},{"location":"api/#artigraph.extras.numpy.ArraySerializer.serialize","title":"serialize  <code>staticmethod</code>","text":"<pre><code>serialize(value: np.ndarray) -&gt; bytes\n</code></pre> <p>Serialize a numpy array.</p> Source code in <code>src/artigraph/extras/numpy.py</code> <pre><code>@staticmethod\ndef serialize(value: np.ndarray) -&gt; bytes:\n\"\"\"Serialize a numpy array.\"\"\"\nif len(value.shape) == NP_1D_SHAPE_LEN:\npd_value = pd.DataFrame({\"1darray\": value})\nelif len(value.shape) == NP_2D_SHAPE_LEN:\npd_value = pd.DataFrame(dict(enumerate(value.T)))\nelse:\nmsg = f\"Can only serialize 1D or 2D arrays, not {value.shape}.\"\nraise ValueError(msg)\nreturn dataframe_serializer.serialize(pd_value)\n</code></pre>"},{"location":"api/#artigraph.extras.pandas.dataframe_serializer","title":"dataframe_serializer  <code>module-attribute</code>","text":"<pre><code>dataframe_serializer = DataFrameSerializer().register()\n</code></pre> <p>A serializer for Pandas dataframes.</p>"},{"location":"api/#artigraph.extras.pandas.DataFrameSerializer","title":"DataFrameSerializer","text":"<p>             Bases: <code>Serializer[DataFrame]</code></p> <p>A serializer for Pandas dataframes.</p> Source code in <code>src/artigraph/extras/pandas.py</code> <pre><code>class DataFrameSerializer(Serializer[pd.DataFrame]):\n\"\"\"A serializer for Pandas dataframes.\"\"\"\ntypes = (pd.DataFrame,)\nname = \"artigraph-pandas\"\n@staticmethod\ndef serialize(value: pd.DataFrame) -&gt; bytes:\n\"\"\"Serialize a Pandas dataframe.\"\"\"\nreturn value.to_parquet()\n@staticmethod\ndef deserialize(value: bytes) -&gt; pd.DataFrame:\n\"\"\"Deserialize a Pandas dataframe.\"\"\"\nreturn pd.read_parquet(BytesIO(value))\n</code></pre>"},{"location":"api/#artigraph.extras.pandas.DataFrameSerializer.deserialize","title":"deserialize  <code>staticmethod</code>","text":"<pre><code>deserialize(value: bytes) -&gt; pd.DataFrame\n</code></pre> <p>Deserialize a Pandas dataframe.</p> Source code in <code>src/artigraph/extras/pandas.py</code> <pre><code>@staticmethod\ndef deserialize(value: bytes) -&gt; pd.DataFrame:\n\"\"\"Deserialize a Pandas dataframe.\"\"\"\nreturn pd.read_parquet(BytesIO(value))\n</code></pre>"},{"location":"api/#artigraph.extras.pandas.DataFrameSerializer.serialize","title":"serialize  <code>staticmethod</code>","text":"<pre><code>serialize(value: pd.DataFrame) -&gt; bytes\n</code></pre> <p>Serialize a Pandas dataframe.</p> Source code in <code>src/artigraph/extras/pandas.py</code> <pre><code>@staticmethod\ndef serialize(value: pd.DataFrame) -&gt; bytes:\n\"\"\"Serialize a Pandas dataframe.\"\"\"\nreturn value.to_parquet()\n</code></pre>"},{"location":"api/#artigraph.extras.plotly.figure_json_serializer","title":"figure_json_serializer  <code>module-attribute</code>","text":"<pre><code>figure_json_serializer = FigureJsonSerializer().register()\n</code></pre> <p>Serialize a plotly figure</p>"},{"location":"api/#artigraph.extras.plotly.FigureJsonSerializer","title":"FigureJsonSerializer","text":"<p>             Bases: <code>Serializer[Figure | FigureWidget]</code></p> <p>Serialize a plotly figure</p> Source code in <code>src/artigraph/extras/plotly.py</code> <pre><code>class FigureJsonSerializer(Serializer[Figure | FigureWidget]):\n\"\"\"Serialize a plotly figure\"\"\"\nname = \"artigraph-plotly-figure-json\"\ntypes = (Figure, FigureWidget)\ndef serialize(self, figure: Figure | FigureWidget) -&gt; bytes:\nresult = plotly_io.to_json(figure)\nif result is None:  # no cov\nmsg = \"Plotly failed to serialize the figure - this is likely an issue with Plotly\"\nraise RuntimeError(msg)\nreturn result.encode()\ndef deserialize(self, data: bytes) -&gt; Figure | FigureWidget:\nreturn plotly_io.from_json(data.decode())\n</code></pre>"},{"location":"api/#artigraph.extras.plotly.figure_from_networkx","title":"figure_from_networkx","text":"<pre><code>figure_from_networkx(\ngraph: nx.Graph, hover_text_line_limit: int = 25\n) -&gt; go.Figure\n</code></pre> <p>Create a figure from a NetworkX graph</p> Source code in <code>src/artigraph/extras/plotly.py</code> <pre><code>def figure_from_networkx(graph: nx.Graph, hover_text_line_limit: int = 25) -&gt; go.Figure:\n\"\"\"Create a figure from a NetworkX graph\"\"\"\nimport networkx as nx\ntry:\nimport pandas as pd\nexcept ImportError:  # nocov\npass\nelse:\npd.set_option(\"display.max_rows\", 20)\npos = nx.multipartite_layout(graph, align=\"horizontal\")\nnode_x = []\nnode_y = []\nfor node in graph.nodes():\nx, y = pos[node]\nnode_x.append(x)\nnode_y.append(y)\nedge_x = []\nedge_y = []\nfor edge in graph.edges():\nx0, y0 = pos[edge[0]]\nx1, y1 = pos[edge[1]]\nedge_x.extend([x0, x1, None])\nedge_y.extend([y0, y1, None])\n# color Artifact green and Node blue\nnode_colors = [\n\"blue\"  # Deep Blue\nif isinstance(graph.nodes[node][\"obj\"], Artifact)\nelse \"yellow\"  # Bright Yellow\nif isinstance(graph.nodes[node][\"obj\"], GraphModel)\nelse \"green\"  # Teal\nfor node in graph.nodes()\n]\nedge_trace = go.Scatter(\nx=edge_x,\ny=edge_y,\nmode=\"lines\",\nline={\"width\": 3},\n)\nnode_trace = go.Scatter(\nx=node_x,\ny=node_y,\nmode=\"markers\",\nhoverinfo=\"text\",\nmarker={\n\"color\": node_colors,\n\"size\": 12,\n\"line_width\": 2,\n},\n)\nnode_text: list[str] = []\n# generate node text from label of parent edge\nfor node in graph.nodes():\nnode_attrs = graph.nodes[node]\ntext = _create_node_hover_text(node_attrs[\"label\"], node_attrs[\"obj\"])\nbr_count = text.count(\"&lt;br&gt;\")\nif br_count &gt; hover_text_line_limit:\ntext = \"&lt;br&gt;\".join(text.split(\"&lt;br&gt;\")[:25] + [\"&lt;br&gt;...\"])\nnode_text.append(text)\nnode_trace.text = node_text\nreturn go.Figure(\ndata=[edge_trace, node_trace],\nlayout=go.Layout(\ntitlefont_size=16,\nshowlegend=False,\nhovermode=\"closest\",\nxaxis={\"showgrid\": False, \"zeroline\": False, \"showticklabels\": False},\nyaxis={\"showgrid\": False, \"zeroline\": False, \"showticklabels\": False},\nhoverlabel={\"font\": {\"family\": \"monospace\", \"size\": 10}},\n),\n)\n</code></pre>"},{"location":"api/#artigraph.extras.polars.dataframe_serializer","title":"dataframe_serializer  <code>module-attribute</code>","text":"<pre><code>dataframe_serializer = DataFrameSerializer().register()\n</code></pre> <p>A serializer for Polars dataframes that uses the parquet file format.</p>"},{"location":"api/#artigraph.extras.polars.DataFrameSerializer","title":"DataFrameSerializer","text":"<p>             Bases: <code>Serializer[DataFrame]</code></p> <p>A serializer for Polars dataframes.</p> Source code in <code>src/artigraph/extras/polars.py</code> <pre><code>class DataFrameSerializer(Serializer[pl.DataFrame]):\n\"\"\"A serializer for Polars dataframes.\"\"\"\ntypes = (pl.DataFrame,)\ndef __init__(self, pyarrow_serializer: ArrowSerializer = parquet_serializer):\nself.pyarrow_serializer = pyarrow_serializer\nself.name = f\"artigraph-polars-{pyarrow_serializer.name}\"\ndef serialize(self, value: pl.DataFrame) -&gt; bytes:\n\"\"\"Serialize a Polars dataframe.\"\"\"\nreturn self.pyarrow_serializer.serialize(value.to_arrow())\ndef deserialize(self, value: bytes) -&gt; pl.DataFrame:\n\"\"\"Deserialize a Polars dataframe.\"\"\"\nreturn pl.from_arrow(self.pyarrow_serializer.deserialize(value))  # type: ignore\n</code></pre>"},{"location":"api/#artigraph.extras.polars.DataFrameSerializer.deserialize","title":"deserialize","text":"<pre><code>deserialize(value: bytes) -&gt; pl.DataFrame\n</code></pre> <p>Deserialize a Polars dataframe.</p> Source code in <code>src/artigraph/extras/polars.py</code> <pre><code>def deserialize(self, value: bytes) -&gt; pl.DataFrame:\n\"\"\"Deserialize a Polars dataframe.\"\"\"\nreturn pl.from_arrow(self.pyarrow_serializer.deserialize(value))  # type: ignore\n</code></pre>"},{"location":"api/#artigraph.extras.polars.DataFrameSerializer.serialize","title":"serialize","text":"<pre><code>serialize(value: pl.DataFrame) -&gt; bytes\n</code></pre> <p>Serialize a Polars dataframe.</p> Source code in <code>src/artigraph/extras/polars.py</code> <pre><code>def serialize(self, value: pl.DataFrame) -&gt; bytes:\n\"\"\"Serialize a Polars dataframe.\"\"\"\nreturn self.pyarrow_serializer.serialize(value.to_arrow())\n</code></pre>"},{"location":"api/#artigraph.extras.pyarrow.feather_serializer","title":"feather_serializer  <code>module-attribute</code>","text":"<pre><code>feather_serializer = ArrowSerializer('feather').register()\n</code></pre> <p>A serializer for PyArrow tables using Feather.</p>"},{"location":"api/#artigraph.extras.pyarrow.parquet_serializer","title":"parquet_serializer  <code>module-attribute</code>","text":"<pre><code>parquet_serializer = ArrowSerializer('parquet').register()\n</code></pre> <p>A serializer for PyArrow tables using Parquet.</p>"},{"location":"api/#artigraph.extras.pyarrow.ArrowSerializer","title":"ArrowSerializer","text":"<p>             Bases: <code>Serializer[Table]</code></p> <p>A serializer for PyArrow tables.</p> Source code in <code>src/artigraph/extras/pyarrow.py</code> <pre><code>class ArrowSerializer(Serializer[pa.Table]):\n\"\"\"A serializer for PyArrow tables.\"\"\"\ntypes = (pa.Table,)\ndef __init__(self, file_format: Literal[\"feather\", \"parquet\"]):\nself.file_format = file_format\nself.name = f\"artigraph-pyarrow-{file_format}\"\ndef serialize(self, value: pa.Table) -&gt; bytes:\n\"\"\"Serialize a PyArrow table.\"\"\"\nif not isinstance(value, pa.Table):\nmsg = f\"Expected a PyArrow table, got {type(value)}\"\nraise TypeError(msg)\nmethod = getattr(self, f\"serialize_{self.file_format}\")\nreturn method(value)\ndef deserialize(self, value: bytes) -&gt; pa.Table:\n\"\"\"Deserialize a PyArrow table.\"\"\"\nmethod = getattr(self, f\"deserialize_{self.file_format}\")\nreturn method(value)\ndef serialize_parquet(self, value: pa.Table) -&gt; bytes:\n\"\"\"Serialize a PyArrow table to Parquet.\"\"\"\nbuffer = BytesIO()\nparquet.write_table(value, buffer)\nreturn buffer.getvalue()\ndef deserialize_parquet(self, value: bytes) -&gt; pa.Table:\n\"\"\"Deserialize a PyArrow table from Parquet.\"\"\"\nbuffer = BytesIO(value)\nreturn parquet.read_table(buffer)\ndef serialize_feather(self, value: pa.Table) -&gt; bytes:\n\"\"\"Serialize a PyArrow table to Feather.\"\"\"\nbuffer = BytesIO()\nfeather.write_feather(value, buffer)\nreturn buffer.getvalue()\ndef deserialize_feather(self, value: bytes) -&gt; pa.Table:\n\"\"\"Deserialize a PyArrow table from Feather.\"\"\"\nbuffer = BytesIO(value)\nreturn feather.read_table(buffer)\n</code></pre>"},{"location":"api/#artigraph.extras.pyarrow.ArrowSerializer.deserialize","title":"deserialize","text":"<pre><code>deserialize(value: bytes) -&gt; pa.Table\n</code></pre> <p>Deserialize a PyArrow table.</p> Source code in <code>src/artigraph/extras/pyarrow.py</code> <pre><code>def deserialize(self, value: bytes) -&gt; pa.Table:\n\"\"\"Deserialize a PyArrow table.\"\"\"\nmethod = getattr(self, f\"deserialize_{self.file_format}\")\nreturn method(value)\n</code></pre>"},{"location":"api/#artigraph.extras.pyarrow.ArrowSerializer.deserialize_feather","title":"deserialize_feather","text":"<pre><code>deserialize_feather(value: bytes) -&gt; pa.Table\n</code></pre> <p>Deserialize a PyArrow table from Feather.</p> Source code in <code>src/artigraph/extras/pyarrow.py</code> <pre><code>def deserialize_feather(self, value: bytes) -&gt; pa.Table:\n\"\"\"Deserialize a PyArrow table from Feather.\"\"\"\nbuffer = BytesIO(value)\nreturn feather.read_table(buffer)\n</code></pre>"},{"location":"api/#artigraph.extras.pyarrow.ArrowSerializer.deserialize_parquet","title":"deserialize_parquet","text":"<pre><code>deserialize_parquet(value: bytes) -&gt; pa.Table\n</code></pre> <p>Deserialize a PyArrow table from Parquet.</p> Source code in <code>src/artigraph/extras/pyarrow.py</code> <pre><code>def deserialize_parquet(self, value: bytes) -&gt; pa.Table:\n\"\"\"Deserialize a PyArrow table from Parquet.\"\"\"\nbuffer = BytesIO(value)\nreturn parquet.read_table(buffer)\n</code></pre>"},{"location":"api/#artigraph.extras.pyarrow.ArrowSerializer.serialize","title":"serialize","text":"<pre><code>serialize(value: pa.Table) -&gt; bytes\n</code></pre> <p>Serialize a PyArrow table.</p> Source code in <code>src/artigraph/extras/pyarrow.py</code> <pre><code>def serialize(self, value: pa.Table) -&gt; bytes:\n\"\"\"Serialize a PyArrow table.\"\"\"\nif not isinstance(value, pa.Table):\nmsg = f\"Expected a PyArrow table, got {type(value)}\"\nraise TypeError(msg)\nmethod = getattr(self, f\"serialize_{self.file_format}\")\nreturn method(value)\n</code></pre>"},{"location":"api/#artigraph.extras.pyarrow.ArrowSerializer.serialize_feather","title":"serialize_feather","text":"<pre><code>serialize_feather(value: pa.Table) -&gt; bytes\n</code></pre> <p>Serialize a PyArrow table to Feather.</p> Source code in <code>src/artigraph/extras/pyarrow.py</code> <pre><code>def serialize_feather(self, value: pa.Table) -&gt; bytes:\n\"\"\"Serialize a PyArrow table to Feather.\"\"\"\nbuffer = BytesIO()\nfeather.write_feather(value, buffer)\nreturn buffer.getvalue()\n</code></pre>"},{"location":"api/#artigraph.extras.pyarrow.ArrowSerializer.serialize_parquet","title":"serialize_parquet","text":"<pre><code>serialize_parquet(value: pa.Table) -&gt; bytes\n</code></pre> <p>Serialize a PyArrow table to Parquet.</p> Source code in <code>src/artigraph/extras/pyarrow.py</code> <pre><code>def serialize_parquet(self, value: pa.Table) -&gt; bytes:\n\"\"\"Serialize a PyArrow table to Parquet.\"\"\"\nbuffer = BytesIO()\nparquet.write_table(value, buffer)\nreturn buffer.getvalue()\n</code></pre>"},{"location":"api/#artigraph.extras.pydantic.PydanticModel","title":"PydanticModel","text":"<p>             Bases: <code>GraphModel</code>, <code>BaseModel</code></p> <p>A base for all artifacts modeled with Pydantic.</p> Source code in <code>src/artigraph/extras/pydantic.py</code> <pre><code>class PydanticModel(GraphModel, _BaseModel, version=1):\n\"\"\"A base for all artifacts modeled with Pydantic.\"\"\"\ngraph_id: UUID = Field(default_factory=uuid1, exclude=True)\n\"\"\"The unique ID of this model.\"\"\"\ndef graph_model_data(self) -&gt; ModelData:\nreturn get_annotated_model_data(\nself,\n[name for name, field in self.model_fields.items() if not field.exclude],\n)\n@classmethod\ndef graph_model_init(cls, info: ModelInfo, kwargs: dict[str, Any]) -&gt; Self:\nreturn cls(graph_id=info.graph_id, **kwargs)\n</code></pre>"},{"location":"api/#artigraph.extras.pydantic.PydanticModel.graph_id","title":"graph_id  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>graph_id: UUID = Field(default_factory=uuid1, exclude=True)\n</code></pre> <p>The unique ID of this model.</p>"},{"location":"building-blocks/","title":"Building Blocks","text":"<p>At the core of Artigraph are nodes and links. Nodes are the vertices of the graph and links are the edges that connect them. Links, the graph edges in Artigraph, are directed (having a <code>source_id</code> and a <code>target_id</code>) and may have an optional label that describes the relationship between the nodes they connect.</p> <p>Nodes which have data associated with them are called artifacts. Artifacts are the primary way you'll store information in Artigraph. You can organize artifacts into models which give structure to the data they contain.</p>"},{"location":"building-blocks/#nodes","title":"Nodes","text":"<p>The Node class forms the backbone of the graphs you'll create with Artigraph. It represents a single vertex in a graph. You can create a node by instantiating the class directly:</p> <pre><code>import artigraph as ag\nnode = ag.Node()\n</code></pre> <p>This won't immediately save the node to the database. To do that, you'll need to call write_one().</p> <pre><code>ag.write_one(node)\n</code></pre> <p>Or, if you need to write more than one node, you can pass write_many() a sequence of nodes.</p> <pre><code>node1 = ag.Node()\nnode2 = ag.Node()\nag.write([node1, node2])\n</code></pre>"},{"location":"building-blocks/#links","title":"Links","text":"<p>Link objects are the edges that connect nodes in a graph. To create one you'll need at least two node. You can then pass their IDs to the constructor:</p> <pre><code>import artigraph as ag\nnode1 = ag.Node()\nnode2 = ag.Node()\nlink = ag.Link(source_id=node1.graph_id, target_id=node2.graph_id)\n</code></pre> <p>Which will form the following relationship:</p> <pre><code>graph LR\n    n1([node1])\n    n2([node2])\n    n1 --&gt; n2</code></pre> <p>Node links can also have a label that describes the relationship between the nodes:</p> <pre><code>link = ag.Link(\nsource_id=node1.graph_id,\ntarget_id=node2.graph_id,\nlabel=\"your-label\",\n)\n</code></pre> <p>That have a labeled edge between them:</p> <pre><code>graph LR\n    n1([node1])\n    n2([node2])\n    n1 -- your-label --&gt; n2</code></pre> <p>You can then write them all to the database:</p> <pre><code>ag.write([node1, node2, link])\n</code></pre>"},{"location":"building-blocks/#artifacts","title":"Artifacts","text":"<p>An Artifact is a node in the graph that additionally has a value. Without specifying anything extra, values are limited to byte strings:</p> <pre><code>import artigraph as ag\nartifact = ag.Artifact(value=b\"Hello, world!\")\n</code></pre> <p>To store other types of data, you'll need to declare a serializer:</p> <pre><code>json_artifact = ag.Artifact(\nvalue={\"hello\": \"world\"},\nserializer=ag.json_serializer,\n)\n</code></pre> <p>You can then write the artifact to the database:</p> <pre><code>ag.write_one(artifact)\n</code></pre> <p>As with nodes, you can relate them with each other or with other nodes using node links:</p> <pre><code>node = ag.Node()\nartifact = ag.Artifact(value=b\"Hello, world!\")\nlink = ag.Link(source_id=node.graph_id, target_id=artifact.graph_id)\nag.write([node, artifact, link])\n</code></pre> <p>Some data is too large to store directly in the database. For that, you can specify a storage location:</p> <pre><code>file_storage = ag.FileSystemStorage(\"path/to/storage/dir\")\nlarge_artifact = ag.Artifact(\nvalue={\"really\": \"big\", \"data\": \"here\"},\nserializer=ag.json_serializer,\nstorage=file_storage,\n)\n</code></pre>"},{"location":"building-blocks/#models","title":"Models","text":"<p>A GraphModel gives structure to the data in your artifacts. The easiest way to create one is using the built-in @dataclass decorator, though other model types exist. The only difference between this decorator and the standard library version is that it must be used on a subclass of <code>GraphModel</code> which requires a version (which will be discussed later). With that in mind, you can define a model like so:</p> <pre><code>import artigraph as ag\n@ag.dataclass\nclass Person(ag.GraphModel, version=1):\nname: str\nage: int\n</code></pre> <p>You can then create an instance of the model and write it to the database:</p> <pre><code>person = Person(name=\"John Doe\", age=42)\nag.write_one(person)\n</code></pre> <p>You'll note here that you didn't have to specify a serializer for non-bytes values. That's because, by default, the fields of a dataclass <code>GraphModel</code> are serialized using the built-in JSON serializer. For fields that are not JSON-serializable or which require external storage, you'll need to annotate them with this information using <code>typing.Annotated</code>:</p> <pre><code>from datetime import datetime\nfrom typing import TypeVar, Annotated\nimport artigraph as ag\nT = TypeVar(\"T\")\nDateTime = Annotated[datetime, ag.datetime_serializer]\nStoreFile = Annotated[T, ag.FileSystemStorage(\"path/to/storage/dir\")]\n@ag.dataclass\nclass Person(ag.GraphModel, version=1):\nname: str\nage: int\nbirthday: DateTime\nphoto: StoreFile[bytes]\nperson = Person(\nname=\"John Doe\",\nage=42,\nbirthday=datetime(1979, 1, 1),\nphoto=b\"a really big photo\",\n)\nag.write_one(person)\n</code></pre>"},{"location":"common-operations/","title":"Standard Operations","text":""},{"location":"common-operations/#read-write-and-delete","title":"Read, Write, and Delete","text":"<p>The core building blocks of Artigraph can be interacted with using the following functions.</p> Object-based functions Query-based functions delete_many() delete() delete_one() exists() write_many() read() write_one() read_one()"},{"location":"common-operations/#object-based-functions","title":"Object-based Functions","text":"<p>The object-based functions take GraphObjects as arguments and either write them to the database or delete them from the database. Usage tends to look like this:</p> <pre><code>import artigraph as ag\nnode = ag.Node()\nag.write_one(node)\nag.delete_one(node)\n</code></pre>"},{"location":"common-operations/#query-based-functions","title":"Query-based Functions","text":"<p>The query-based functions take Filter objects (learn more) as arguments and either read or delete objects from the database. Usage tends to look like this:</p> <pre><code>import artigraph as ag\nnode = ag.Node()\nag.write_one(node)\nnode = ag.read_one(ag.NodeFilter(id=node.graph_id))\nag.delete(ag.NodeFilter(id=node.graph_id))\n</code></pre>"},{"location":"common-operations/#sessions","title":"Sessions","text":"<p>By default, Artigraph will create a new database session for each function call you make. This is fine for most use cases, but if you're making a lot of calls to the database, it can be more efficient to use a single session for all of your calls. You can do this by using the current_session() context manager:</p> <pre><code>import artigraph as ag\nwith ag.current_session() as session:\nnode = ag.Node()\nag.write_one(node)\nnode = ag.read_one(ag.NodeFilter(id=node.graph_id))\nag.delete_one(node)\n</code></pre>"},{"location":"common-operations/#async-usage","title":"Async Usage","text":"<p>Artigraph is designed for both synchronous and asynchronous usage. To allow for this, Artigraph uses a bit of magic to figure out if it should run synchronously or asynchronously depending on the context. In short, if there's a running event loop, Artigraph will run asynchronously, and if there's not, it will do so synchronously.</p> <p>Note</p> <p>Jupyter Notebooks and IPython shells have a running event loop by default. If you're using Artigraph in a Jupyter Notebook or IPython shell, you'll need to call Artigraph functions asynchronously.</p> <p>For example, write_one() can be used synchronously like this:</p> <pre><code>import artigraph as ag\nnode = ag.Node()\nag.write_many(node)\n</code></pre> <p>While asynchronous use looks like this:</p> <pre><code>import asyncio\nimport artigraph as ag\nasync def main():\nnode = ag.Node()\nawait ag.write_one(node)\nasyncio.run(main())\n</code></pre> <p>Context managers also work in both synchronous and asynchronous contexts:</p> <pre><code>with ag.current_session() as session:\n...\n</code></pre> <p>And the async counter-part:</p> <pre><code>import asyncio\nasync def main():\nasync with ag.current_session() as session:\n...\nasyncio.run(main())\n</code></pre>"},{"location":"common-operations/#explicit-sync-or-async-usage","title":"Explicit Sync or Async Usage","text":"<p>Sometimes you may run into situations where the implicit sync or async behavior described above doesn't work for you. For example, you need to call one of these functions synchronously even though there's a running event loop. In these cases, you can force Artigraph to use the sync or async version of a function by accessing the <code>.a</code> or <code>.s</code> attributes of the function you're calling.</p> <p>For example, if you needed to use the synchronous version of write_one in the presebnce of a running event loop, you can do so like this:</p> <pre><code>import asyncio\nimport artigraph as ag\nasync def main():\nnode = ag.Node()\nag.write_one.s(node)\nasyncio.run(main())\n</code></pre> <p>Being able to be explicit about whether you're using a sync or async version of a function can also be useful when working with type checkers since the return type of the dual-use function (without the <code>.a</code> or <code>.s</code>) will be the union <code>Awaitable[T] | T</code> where <code>T</code> is the return type of the function.</p>"},{"location":"creating-graphs/","title":"Creating Graphs","text":"<p>While you can already create graphs out of the basic building blocks and operations Artigraph provides, it can be tedious to do so.</p>"},{"location":"creating-graphs/#linker-context","title":"Linker Context","text":"<p>Artigraph provides a more convenient way to create graphs likes this with a Linker. A linker is a context manager which accepts a node (and an optional label) that allows you to link() data to it. So instead of writing:</p> <pre><code>import artigraph as ag\n@ag.dataclass\nclass MyModel(ag.GraphModel, version=1):\nsome_value: int\nanother_value: dict[str, str]\nnode = ag.Node()\nmodel = MyModel(some_value=42, another_value={\"foo\": \"bar\"})\nlink = ag.Link(source_id=node.graph_id, target_id=model.graph_id, label=\"my_model\")\nag.write_many([node, model, link])\n</code></pre> <p>You can instead write the latter portion as:</p> <pre><code>with ag.Linker(ag.Node()) as root:\nroot.link(\nMyModel(some_value=42, another_value={\"foo\": \"bar\"}),\nlabel=\"my_model\"\n)\n</code></pre> <p>The data you link to a node doesn't have to be a model. You can link anything that your currently registered serializers know how to serialize. For example, you can link a dictionary since Artigraph comes with a built-in JSON serializer:</p> <pre><code>with ag.Linker(ag.Node()) as root:\nroot.link({\"foo\": \"bar\"}, label=\"my_dict\")\n</code></pre> <p><code>Linker</code>s also allow you to attach data to nodes \"at a distance\" because you can always access the currently active linker with the current_linker() function. This allows you to write code like this:</p> <pre><code>def create_model():\nmodel = MyModel(some_value=42, another_value={\"foo\": \"bar\"})\ncurrent_linker().link(model, label=\"my_model\")\nreturn model\nwith ag.Linker(ag.Node()) as root:\ncreate_model()\n</code></pre>"},{"location":"creating-graphs/#linked-functions","title":"Linked Functions","text":"<p>In addition to the linker context manager, Artigraph provides a linked() decorator that allows you to link the inputs and outputs of a function to a node. This is useful for tracing the execution of functions in a data pipeline.</p> <pre><code>import artigraph as ag\n@ag.linked()\ndef my_function(a: int, b: int) -&gt; int:\nreturn a + b\nwith ag.Linker(ag.Node()) as root:\nmy_function(1, 2)\nmy_function(3, 4)\n</code></pre> <p>The above code will create the following graph:</p> <pre><code>graph TD\n    r([ ])\n    mf1([ ])\n    mf2([ ])\n\n    mf1_a[1]\n    mf1_b[2]\n    mf1_return[3]\n    mf2_a[3]\n    mf2_b[4]\n    mf2_return[7]\n\n    r --&gt; |\"my_function[1]\"| mf1\n    r --&gt; |\"my_function[2]\"| mf2\n    mf1 --&gt; |a| mf1_a\n    mf1 --&gt; |b| mf1_b\n    mf1 --&gt; |return| mf1_return\n    mf2 --&gt; |a| mf2_a\n    mf2 --&gt; |b| mf2_b\n    mf2 --&gt; |return| mf2_return</code></pre> <p>Note</p> <p>Linked functions must be called within a <code>Linker</code> context manager.</p> <p>If you want to limit what's saved by a linked function, you can pass either <code>include</code> or <code>exclude</code> arguments to the decorator. These arguments are one or more strings that specify whether to save arguments or the return value. For example, to only save the return value of a function, you can write:</p> <pre><code>@ag.linked(include=\"return\")\ndef my_function(a: int, b: int) -&gt; int:\nreturn a + b\n</code></pre> <p>Doing so will create the following graph:</p> <pre><code>graph TD\n    r([ ])\n    mf1([ ])\n    mf2([ ])\n\n    mf1_return[3]\n    mf2_return[7]\n\n    r --&gt; |\"my_function[1]\"| mf1\n    r --&gt; |\"my_function[2]\"| mf2\n    mf1 --&gt; |return| mf1_return\n    mf2 --&gt; |return| mf2_return</code></pre>"},{"location":"database-schema/","title":"Database Schema","text":"<p>Artigraph defines a graph database within SQLAlchemy.</p>"},{"location":"database-schema/#link","title":"Link","text":"<p>Linkages between nodes are stored in the <code>artigraph_link</code> table whose base set of columns are describe by the OrmLink class:</p> Column Type Description <code>id</code> <code>UUID</code> The primary key of the link. <code>source_id</code> <code>UUID</code> The primary key of the source node. <code>target_id</code> <code>UUID</code> The primary key of the target node. <code>label</code> <code>String</code> (nullable) The label of the link. <p>Note</p> <p>Labels are not required, but if supplied must be unique for a given source node.</p>"},{"location":"database-schema/#node","title":"Node","text":"<p>Most data in Artigraph is stored in a single <code>artigraph_node</code> table whose base set of columns are describe by the OrmNode class:</p> Column Type Description <code>id</code> <code>UUID</code> The primary key of the node. <code>node_type</code> <code>String</code> The type of the node (comes from its <code>polymorphic_identity</code>) <code>node_created_at</code> <code>DateTime</code> The time the node was created. <code>node_updated_at</code> <code>DateTime</code> The time the node was last updated. <p>Subclasses of <code>OrmNode</code> utilize single table inheritance to extend the table. As a result of this inheritance strategy, and to avoid name collisions, <code>OrmNode</code>'s columns are prefixed with <code>node_</code>. Subclasses of <code>OrmNode</code> ought to do the same. For example, the OrmArtifact class defines its columns with an <code>artifact_</code> prefix.</p>"},{"location":"database-schema/#node-inheritance","title":"Node Inheritance","text":"<p>Here's an example of what a different <code>OrmNode</code> subclass might look like:</p> <pre><code>import artigraph as ag\nfrom sqlalchemy import UniqueConstraint\nfrom sqlalchemy.declarative import Mapped, mapped_column\nclass MyOrmNode(ag.OrmNode):\n__mapper_args__ = {\"polymorphic_identity\": \"my_node\"}\n__table_args = (UniqueConstraint(\"node_source_id\", \"my_node_label\"),)\nmy_node_label: Mapped[str] = mapped_column(nullable=True)\n</code></pre> <p>Note that even though the type annotation on <code>my_node_label</code> is <code>str</code>, the column is marked as nullable. This is because all <code>OrmNode</code> subclasses are stored in the same table and, as such, not all columns will be populated by all rows. Making a column non-nullable will cause other <code>OrmNode</code> class instances to fail to save to the database since they lack a non-nullable column from another subclass.</p> <p>Under the hood <code>artigraph</code> does several somewhat magical things. First, it inspects the <code>__mapper_args__</code> for the <code>polymorphic_identity</code> and saves that as a class attribute (e.g. <code>MyNode.polymorphic_identity = \"my_node\"</code>). Second, since <code>__table_args__</code> cannot typically be defined on subclasses without a <code>__tablename__</code>, as all subclasses of <code>OrmNode</code> must to use single table inheritance, Artigraph shuttles the <code>__table_args__</code> to the <code>OrmNode</code> class. Lastly, artigraph looks at any foreign keys and tries to determine what order they should be created in to avoid foreign key constraint violations.</p> <p>Note</p> <p>Circular foreign keys are not supported at this time.</p>"},{"location":"database-schema/#single-table-inheritance","title":"Single Table Inheritance","text":"<p>Artigraph uses single table inheritance (STI) to store all data in a single table. This comes with advantages and disadvantages compared to concrete table inheritance. The primary advantage of STI is that the database schema is drastically simplified since there's only one table to manage - queries can avoid joins and thus be more performant. The disadvantages of STI come from a lack of separation - making independent schema changes may be challenging.</p> <p>It's worth keeping these tradeoffs in mind as you extend Artigraph. The main way to mitigate the disadvantages of STI is to keep the number of <code>OrmNode</code> subclasses to a minimum. Thankfully, the base primitives of Artigraph are powerful enough to support a wide variety of use cases. In general, if you find yourself needing to add a new</p> <p>Note</p> <p>Thankfully most modern databases do not suffer from size issues if a table is sparse. For example, in PostgreSQL a null bitmap is used to mark which columns are null for any row with at least one null value. As such, the size of a sparse row is identical to one that is well (but not completely) populated.</p>"},{"location":"database-schema/#artifact","title":"Artifact","text":"<p>OrmArtifact is a subclass of <code>OrmNode</code> that defines a set of columns that are shared by all artifacts. It does not contain data or describe where data may be found. Its columns are:</p> Column Type Description <code>artifact_serializer</code> <code>String</code> The name of the serializer used to serialize the artifact. <p>Of note is the <code>artifact_serializer</code> which maps to a serializer by name.</p>"},{"location":"database-schema/#database-artifact","title":"Database Artifact","text":"<p>OrmDatabaseArtifact is a subclass of <code>OrmArtifact</code> that stores data directly in the database. It defines a single column for that purpose:</p> Column Type Description <code>database_artifact_data</code> <code>Bytes</code> The data of the artifact."},{"location":"database-schema/#model-artifact","title":"Model Artifact","text":"<p>OrmModelArtifact is a subclass of <code>DatabaseArtifact</code> that stores the root node of a model.</p> Column Type Description <code>model_artifact_type_name</code> <code>str</code> The name of the model type <code>model_artifact_version</code> <code>int</code> The version of the model"},{"location":"database-schema/#remote-artifact","title":"Remote Artifact","text":"<p>OrmRemoteArtifact is a subclass of <code>OrmArtifact</code> that represents an artifact that is stored somewhere else other than the database. Since the data itself is stored elsewhere, all that is stored in the database is a pointer to the artifact. To do this it defines:</p> Column Type Description <code>remote_artifact_storage</code> <code>String</code> The name of the storage backend. <code>remote_artifact_location</code> <code>String</code> The location of the data in in the storage backend. <p>The <code>remote_artifact_storage</code> column maps to a storage backend by name.</p>"},{"location":"database-schema/#graph-models","title":"Graph Models","text":"<p>The dataclass-like usage of <code>GraphModel</code> belies the fact that its underlying implementation builds atop database, remote and model artifacts. Under the hood, the hierarchy of a <code>GraphModel</code> and its fields are replicated in the database. So saving a <code>GraphModel</code> like the one below:</p> <pre><code>import artigraph as ag\n@ag.dataclass\nclass MyDataModel(ag.GraphModel, version=1):\nsome_value: int\ninner_model: MyDataModel | None = None\nmy_data = MyDataModel(some_value=1, inner_model=MyDataModel(some_value=2))\nag.write_one(my_data)\n</code></pre> <p>Will result in the following graph being created in the database</p> <pre><code>graph TB\n    m1([\"ModelArtifact(type='MyDataModel', version=1)\"])\n    f1([\"DatabaseArtifact(data=1)\"])\n    m2([\"DatabaseArtifact(type='MyDataModel', version=1)\"])\n    f2([\"DatabaseArtifact(data=2)\"])\n    f3([\"DatabaseArtifact(data=None)\"])\n\n    m1 --&gt; |some_value| f1\n    m1 --&gt; |inner_model| m2\n    m2 --&gt; |some_value| f2\n    m2 --&gt; |inner_model| f3</code></pre>"},{"location":"filtering/","title":"Filtering","text":"<p>Artigraph allows you to inspect graphs using filters. Filters can be composed together to create a wide variety of complex queries so the examples below will show just some of the ways they can be used. They'll assume the following code graph structure and highlight in green, links or nodes that are selected by the described filters.</p> <pre><code>import time\nimport artigraph as ag\nfrom artigraph.extras.networkx import create_graph\nfrom artigraph.extras.plotly import figure_from_networkx\nag.set_engine(\"sqlite+aiosqlite:///:memory:\", create_tables=True)\n@ag.trace_function()\ndef add(x: int, y: int) -&gt; int:\nreturn x + y\n@ag.trace_function()\ndef sub(x: int, y: int) -&gt; int:\nreturn x - y\n@ag.trace_function()\ndef do_math() -&gt; \"DidMath\":\nstart = time.time()\nresult = sub(4, add(1, 2))\nelapsed_time = time.time() - start\nreturn DidMath(result, elapsed_time)\n@ag.dataclass\nclass DidMath(ag.GraphModel, version=1):\nvalue: int\nelapsed_time: float\nwith ag.Linker(ag.Node()) as root:\ndo_math()\ngraph = create_graph(root.node)\nfig = figure_from_networkx(graph)\nfig.show()\n</code></pre> <pre><code>graph TD\n    r([ ])\n    d([ ])\n    a([ ])\n    s([ ])\n    d_return[DidMath]\n    d_return_value[1]\n    d_return_elapsed_time[0.001]\n    a_x[1]\n    a_y[2]\n    a_return[3]\n    s_x[4]\n    s_y[3]\n    s_return[1]\n\n    r --&gt; |do_math| d\n    d --&gt; |add| a\n    d --&gt; |sub| s\n    d --&gt; |return| d_return\n    a --&gt; |x| a_x\n    a --&gt; |y| a_y\n    a --&gt; |return| a_return\n    s --&gt; |x| s_x\n    s --&gt; |y| s_y\n    s --&gt; |return| s_return\n    d_return --&gt; |value| d_return_value\n    d_return --&gt; |elapsed_time| d_return_elapsed_time</code></pre>"},{"location":"filtering/#base-filter","title":"Base Filter","text":"<p>Filter is the base class for all filters. A filter is simply a dataclass-like object that implements a compose() method that takes and returns a SQLAlchemy expression object. Inside the compose() method you can modify the expression object to add conditions to the query. For example, the following filter will only select nodes that have a parent:</p> <pre><code>import artigraph as ag\nfrom sqlalchemy import select\nclass MyFilter(ag.Filter):\nmust_have_parent: bool = False\ndef compose(self, expr):\nif self.must_have_parent:\nexpr &amp;= ag.OrmNode.id.in_(select(ag.OrmLink.source_id))\nreturn expr\n</code></pre> <p>You can then compose multiple filters using the <code>&amp;</code> and <code>|</code> operators:</p> <pre><code>await read_node(NodeFilter(id=2) &amp; MyFilter(must_have_parent=True))\n</code></pre>"},{"location":"filtering/#node-filter","title":"Node Filter","text":"<p>A NodeFilter is a higher-level filter that allows you to compose common node-related filter conditions together. It is also the base class for filters that apply to node subclasses such as ArtifactFilter and ModelFilter. It can be used to select nodes based on their properties, relationships, or type. For example you can select by node id:</p> <pre><code>import artigraph as ag\nag.read(ag.Node, ag.NodeFilter(label=\"do_math\"))\n</code></pre> <pre><code>graph TD\n    r([ ])\n    d([ ])\n    a([ ])\n    s([ ])\n    d_return[DidMath]\n    d_return_value[1]\n    d_return_elapsed_time[0.001]\n    a_x[1]\n    a_y[2]\n    a_return[3]\n    s_x[4]\n    s_y[3]\n    s_return[1]\n\n    style d stroke:green,stroke-width:2px\n\n    r --&gt; |do_math| d\n    d --&gt; |add| a\n    d --&gt; |sub| s\n    d --&gt; |return| d_return\n    a --&gt; |x| a_x\n    a --&gt; |y| a_y\n    a --&gt; |return| a_return\n    s --&gt; |x| s_x\n    s --&gt; |y| s_y\n    s --&gt; |return| s_return\n    d_return --&gt; |value| d_return_value\n    d_return --&gt; |elapsed_time| d_return_elapsed_time</code></pre>"},{"location":"filtering/#node-type-filter","title":"Node Type Filter","text":"<p>The NodeTypeFilter allows you to select nodes based on their type. By default, it will select all nodes that are instances of the given type or any of its subclasses. You can change this behavior by setting <code>subclasses=False</code> to only select nodes that are instances of the given type.</p> <pre><code>import artigraph as ag\nawait read(Node, NodeTypeFilter(type=ag.OrmNode, subclasses=False))\n</code></pre> <pre><code>graph TD\n    r([ ])\n    d([ ])\n    a([ ])\n    s([ ])\n    d_return[DidMath]\n    d_return_value[1]\n    d_return_elapsed_time[0.001]\n    a_x[1]\n    a_y[2]\n    a_return[3]\n    s_x[4]\n    s_y[3]\n    s_return[1]\n\n    style r stroke:green,stroke-width:2px\n    style d stroke:green,stroke-width:2px\n    style a stroke:green,stroke-width:2px\n    style s stroke:green,stroke-width:2px\n\n    r --&gt; |do_math| d\n    d --&gt; |add| a\n    d --&gt; |sub| s\n    d --&gt; |return| d_return\n    a --&gt; |x| a_x\n    a --&gt; |y| a_y\n    a --&gt; |return| a_return\n    s --&gt; |x| s_x\n    s --&gt; |y| s_y\n    s --&gt; |return| s_return\n    d_return --&gt; |value| d_return_value\n    d_return --&gt; |elapsed_time| d_return_elapsed_time</code></pre>"},{"location":"filtering/#artifact-filter","title":"Artifact Filter","text":"<p>The ArtifactFilter allows you to select nodes which inherit from Artifact. It accomplished this by setting a default value for NodeFilter.node_type. For example, you can select artifacts by their label:</p> <pre><code>import artigraph as ag\nag.read(ag.Artifact, ag.ArtifactFilter())\n</code></pre> <pre><code>graph TD\n    r([ ])\n    d([ ])\n    a([ ])\n    s([ ])\n    d_return[DidMath]\n    d_return_value[1]\n    d_return_elapsed_time[0.001]\n    a_x[1]\n    a_y[2]\n    a_return[3]\n    s_x[4]\n    s_y[3]\n    s_return[1]\n\n    style d_return stroke:green,stroke-width:2px\n    style d_return_value stroke:green,stroke-width:2px\n    style d_return_elapsed_time stroke:green,stroke-width:2px\n    style a_x stroke:green,stroke-width:2px\n    style a_y stroke:green,stroke-width:2px\n    style a_return stroke:green,stroke-width:2px\n    style s_x stroke:green,stroke-width:2px\n    style s_y stroke:green,stroke-width:2px\n    style s_return stroke:green,stroke-width:2px\n\n    r --&gt; |do_math| d\n    d --&gt; |add| a\n    d --&gt; |sub| s\n    d --&gt; |return| d_return\n    a --&gt; |x| a_x\n    a --&gt; |y| a_y\n    a --&gt; |return| a_return\n    s --&gt; |x| s_x\n    s --&gt; |y| s_y\n    s --&gt; |return| s_return\n    d_return --&gt; |value| d_return_value\n    d_return --&gt; |elapsed_time| d_return_elapsed_time</code></pre>"},{"location":"filtering/#model-filter","title":"Model Filter","text":"<p>The ModelFilter allows you to select nodes which inherit from GraphModel. It accomplishes this by setting a default value for NodeFilter.node_type. You can use this to select models by their type.</p> <pre><code>import artigraph as ag\nag.read(ag.GraphModel, ag.ModelFilter(model_type=DidMath))\n</code></pre> <pre><code>graph TD\n    r([ ])\n    d([ ])\n    a([ ])\n    s([ ])\n    d_return[DidMath]\n    d_return_value[1]\n    d_return_elapsed_time[0.001]\n    a_x[1]\n    a_y[2]\n    a_return[3]\n    s_x[4]\n    s_y[3]\n    s_return[1]\n\n    style d_return stroke:green,stroke-width:2px\n\n    r --&gt; |do_math| d\n    d --&gt; |add| a\n    d --&gt; |sub| s\n    d --&gt; |return| d_return\n    a --&gt; |x| a_x\n    a --&gt; |y| a_y\n    a --&gt; |return| a_return\n    s --&gt; |x| s_x\n    s --&gt; |y| s_y\n    s --&gt; |return| s_return\n    d_return --&gt; |value| d_return_value\n    d_return --&gt; |elapsed_time| d_return_elapsed_time</code></pre>"},{"location":"filtering/#value-filter","title":"Value Filter","text":"<p>The ValueFilter allows you to select individual values by comparing them to one or more given values. It does not allow you filter nodes directly but might be useful to do so indirectly by comparing values of a node's properties. Many other filters support using ValueFilters. For example NodeFilter.id can be a ValueFilter instead of an integer:</p> <pre><code>import artigraph as ag\nag.read(ag.Artifact, ag.ArtifactFilter(label=ValueFilter(not_in=[\"x\", \"y\"])))\n</code></pre> <pre><code>graph TD\n    r([ ])\n    d([ ])\n    a([ ])\n    s([ ])\n    d_return[DidMath]\n    d_return_value[1]\n    d_return_elapsed_time[0.001]\n    a_x[1]\n    a_y[2]\n    a_return[3]\n    s_x[4]\n    s_y[3]\n    s_return[1]\n\n    style d_return stroke:green,stroke-width:2px\n    style d_return_value stroke:green,stroke-width:2px\n    style d_return_elapsed_time stroke:green,stroke-width:2px\n    style a_return stroke:green,stroke-width:2px\n    style s_return stroke:green,stroke-width:2px\n\n    r --&gt; |do_math| d\n    d --&gt; |add| a\n    d --&gt; |sub| s\n    d --&gt; |return| d_return\n    a --&gt; |x| a_x\n    a --&gt; |y| a_y\n    a --&gt; |return| a_return\n    s --&gt; |x| s_x\n    s --&gt; |y| s_y\n    s --&gt; |return| s_return\n    d_return --&gt; |value| d_return_value\n    d_return --&gt; |elapsed_time| d_return_elapsed_time</code></pre>"},{"location":"models/","title":"Models","text":"<p>A GraphModel provides a way to store structured data in Artigraph.</p> <p>You can use one of the built-in models or you can create your own.</p>"},{"location":"models/#built-in-models","title":"Built-in Models","text":"Model Description core.model.dataclasses.dataclass A model that uses the standard library dataclasses module. extra.pydantic.PydanticModel A model that uses the Pydantic library."},{"location":"models/#pydantic","title":"Pydantic","text":"<p>Artigraph integrates with Pydantic and provides a PydanticModel that you can subclass to get all the benefits of Pydantic with the added power of being able to store your models as a graph with Artigraph. with the exception of needing to inherit from <code>PydanticModel</code> and specify a version, you can use it just like you would any other Pydantic model:</p> <pre><code>import artigraph as ag\nfrom pydantic import Field\nclass Person(ag.PydanticModel, version=1):\nname: str = Field(..., description=\"The person's name.\")\nage: int = Field(..., description=\"The person's age.\")\n</code></pre> <p>You can specify serializers and storage for fields just like you would with the built-in dataclass model:</p> <pre><code>from typing import Annotated\nimport artigraph as ag\nfrom pydantic import Field\nDateTime = Annotated[datetime, ag.datetime_serializer]\nclass Person(ag.PydanticModel, version=1):\nname: str = Field(..., description=\"The person's name.\")\nage: int = Field(..., description=\"The person's age.\")\nbirthday: DateTime = Field(..., description=\"The person's birthday.\")\n</code></pre>"},{"location":"models/#custom-models","title":"Custom Models","text":"<p>To create a custom model, you must subclass <code>GraphModel</code>, specify a version, and define the following:</p> <ul> <li>graph_id - Id of the root node of the model.</li> <li>graph_model_data() - Data to be stored in     the database.</li> <li>graph_model_init() - Method to initialize     the model from the data.</li> </ul> <p>Here's an exmaple of a custom model:</p> <pre><code>from typing import Self\nfrom uuid import UUID, uuid1\nimport artigraph as ag\nclass MyModel(ag.GraphModel, version=1):\ndef __init__(self, data: Any, graph_id: UUID | None = None) -&gt; None:\nself.data = data\nself.graph_id = graph_id or uuid1()\ndef graph_model_data(self) -&gt; dict[str, tuple[Any, ag.SaveSpec]]:\nreturn {\n\"data\": (self.data, ag.SaveSpec(serializer=ag.json_serializer)),\n}\n@classmethod\ndef graph_model_init(cls, info: ag.ModelInfo, kwargs: dict[str, Any]) -&gt; Self:\nreturn cls(**kwargs, graph_id=info.graph_id)\n</code></pre> <p>It's worth noting that the <code>ModelInfo</code> supplied to <code>graph_model_init()</code> when initializing a model from the database contains the <code>version</code> of the model data from the database. This allows you to handle migrations if you need to. For example, if you wanted to rename the <code>data</code> field in the model above to <code>my_data</code>, you could do so like this:</p> <pre><code>class MyModel(ag.GraphModel, version=2):\ndef __init__(self, my_data: Any, graph_id: UUID | None = None) -&gt; None:\nself.my_data = my_data\nself.graph_id = graph_id or uuid1()\ndef graph_model_data(self) -&gt; dict[str, tuple[Any, ag.SaveSpec]]:\nreturn {\n\"my_data\": (self.data, ag.SaveSpec(serializer=ag.json_serializer)),\n}\n@classmethod\ndef graph_model_init(cls, info: ag.ModelInfo, kwargs: dict[str, Any]) -&gt; Self:\nif info.version == 1:\nkwargs[\"my_data\"] = kwargs.pop(\"data\")\nreturn cls(**kwargs, graph_id=info.graph_id)\n</code></pre>"},{"location":"serializers/","title":"Serializers","text":"<p>Artifacts are serialized before being stored in the database. This allows you to store arbitrary data types in your artifacts. You can use the built-in serializers or you can create your own.</p>"},{"location":"serializers/#built-in-serializers","title":"Built-in Serializers","text":"Serializer Description core.serializer.datetime.datetime_serializer Date Times core.serializer.json.json_serializer JSON core.serializer.json.json_sorted_serializer JSON with sorted keys extra.numpy.array_serializer 1d and 2d Numpy Arrays extra.pandas.dataframe_serializer Pandas DataFrames extra.plotly.figure_json_serializer Plotly Figures extra.polars.dataframe_serializer Polars DataFrames extra.pyarrow.feather_serializer PyArrow Feather Files extra.pyarrow.parquet_serializer PyArrow Parquet Files"},{"location":"serializers/#custom-serializers","title":"Custom Serializers","text":"<p>You can create your own serializer by subclassing <code>artigraph.serializer.Serializer</code>:</p> <pre><code>from typing import TypeVar\nfrom artigraph.serializer import Serializer\nT = TypeVar(\"T\")\nclass CustomSerializer(Serializer[T]):\ntypes = (object,)\n\"\"\"The types that this serializer can handle\"\"\"\ndef __init__(self):\n# This must be GLOBALLY unique and stable across versions!\nself.name = \"custom-serializer\"\ndef serialize(self, value: T) -&gt; bytes:\n\"\"\"serialize the value to bytes\"\"\"\ndef deserialize(self, value: bytes) -&gt; T:\n\"\"\"deserialize the value from bytes\"\"\"\nCustomSerializer().register()\n</code></pre>"},{"location":"setup/","title":"Initial Setup","text":""},{"location":"setup/#installation","title":"Installation","text":"<p>To install Artigraph and all its extra dependencies, run:</p> <pre><code>pip install \"artigraph[all]\"\n</code></pre> <p>To install only a select set of dependencies replace <code>all</code> with any of:</p> <p><code>aws</code> <code>networkx</code> <code>numpy</code> <code>pandas</code> <code>plotly</code> <code>polars</code> <code>pyarrow</code> <code>pydantic</code></p>"},{"location":"setup/#setting-up-the-database","title":"Setting up the Database","text":"<p>First, you need to set up an async SQLAlchemy engine and create the Artigraph tables. The quickest way to do this is to use the set_engine() function, pass it a conntection string or any engine object, and set <code>create_tables=True</code>. You won't need <code>create_tables=True</code> if you're using a database that already has the tables created.</p> <pre><code>import artigraph as ag\nag.set_engine(\"sqlite+aiosqlite:///example.db\", create_tables=True)\n# Do stuff with Artigraph\n</code></pre> <p>You can also use current_engine() to establish an engine for use within a particular block of code:</p> <pre><code>with ag.current_engine(\"sqlite+aiosqlite:///example.db\", create_tables=True):\n# Do stuff with Artigraph\n</code></pre> <p>Note</p> <p>You'll need to install <code>aiosqlite</code> for the above code to work.</p>"},{"location":"storage/","title":"Storage","text":"<p>The data from artifacts can be stored in a variety of locations. By default, artifact data is stored in the database itself. However, you can specify a storage backend to save it elsewhere. You can use one of the built-in storage backends or you can create your own.</p>"},{"location":"storage/#built-in-storage-backends","title":"Built-in Storage Backends","text":"Storage Description core.storage.file.FileSystemStorage Local filesystem extra.storage.aws.S3Storage AWS S3"},{"location":"storage/#custom-storage-backends","title":"Custom Storage Backends","text":"<p>You can create your own storage backend by subclassing <code>artigraph.storage.Storage</code>:</p> <pre><code>from artigraph.storage import Storage\nclass CustomStorage(Storage):\ndef __init__(self):\n# This must be GLOBALLY unique and stable across versions!\nself.name = \"custom-storage\"\nasync def create(self, data: bytes) -&gt; str:\n\"\"\"Create the artifact data and return its location.\"\"\"\nasync def read(self, location: str) -&gt; bytes:\n\"\"\"Read artifact data from the given location.\"\"\"\nasync def update(self, location: str, data: bytes) -&gt; None:\n\"\"\"Update artifact data at the given location.\"\"\"\nasync def delete(self, location: str) -&gt; None:\n\"\"\"Delete artifact data at the given location.\"\"\"\nasync def exists(self, location: str) -&gt; bool:\n\"\"\"Check if artifact data exists at the given location.\"\"\"\nCustomStorage().regiser()\n</code></pre>"}]}